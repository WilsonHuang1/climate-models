# This file is automatically generated by _generate_pyx.py.
# Do not edit manually!

from libc.math cimport NAN

include "_ufuncs_extra_code_common.pxi"
include "_ufuncs_extra_code.pxi"
__all__ = ['agm', 'bdtr', 'bdtrc', 'bdtri', 'bdtrik', 'bdtrin', 'besselpoly', 'beta', 'betainc', 'betaincc', 'betainccinv', 'betaincinv', 'betaln', 'boxcox', 'boxcox1p', 'btdtr', 'btdtri', 'btdtria', 'btdtrib', 'cbrt', 'chdtr', 'chdtrc', 'chdtri', 'chdtriv', 'chndtr', 'chndtridf', 'chndtrinc', 'chndtrix', 'cosdg', 'cosm1', 'cotdg', 'dawsn', 'ellipe', 'ellipeinc', 'ellipj', 'ellipk', 'ellipkinc', 'ellipkm1', 'elliprc', 'elliprd', 'elliprf', 'elliprg', 'elliprj', 'entr', 'erf', 'erfc', 'erfcinv', 'erfcx', 'erfi', 'erfinv', 'eval_chebyc', 'eval_chebys', 'eval_chebyt', 'eval_chebyu', 'eval_gegenbauer', 'eval_genlaguerre', 'eval_hermite', 'eval_hermitenorm', 'eval_jacobi', 'eval_laguerre', 'eval_legendre', 'eval_sh_chebyt', 'eval_sh_chebyu', 'eval_sh_jacobi', 'eval_sh_legendre', 'exp10', 'exp2', 'expm1', 'expn', 'fdtr', 'fdtrc', 'fdtri', 'fdtridfd', 'fresnel', 'gammainc', 'gammaincc', 'gammainccinv', 'gammaincinv', 'gammasgn', 'gdtr', 'gdtrc', 'gdtria', 'gdtrib', 'gdtrix', 'huber', 'hyp0f1', 'hyp1f1', 'hyperu', 'i0', 'i0e', 'i1', 'i1e', 'inv_boxcox', 'inv_boxcox1p', 'j0', 'j1', 'k0', 'k0e', 'k1', 'k1e', 'kl_div', 'kn', 'kolmogi', 'kolmogorov', 'log1p', 'log_ndtr', 'lpmv', 'modstruve', 'nbdtr', 'nbdtrc', 'nbdtri', 'nbdtrik', 'nbdtrin', 'ncfdtr', 'ncfdtri', 'ncfdtridfd', 'ncfdtridfn', 'ncfdtrinc', 'nctdtr', 'nctdtridf', 'nctdtrinc', 'nctdtrit', 'ndtr', 'ndtri', 'ndtri_exp', 'nrdtrimn', 'nrdtrisd', 'owens_t', 'pdtr', 'pdtrc', 'pdtri', 'pdtrik', 'poch', 'powm1', 'pseudo_huber', 'radian', 'rel_entr', 'round', 'shichi', 'sici', 'sindg', 'smirnov', 'smirnovi', 'spence', 'stdtr', 'stdtridf', 'stdtrit', 'struve', 'tandg', 'tklmbda', 'voigt_profile', 'wofz', 'wrightomega', 'xlog1py', 'xlogy', 'y0', 'y1', 'yn', 'zetac', 'geterr', 'seterr', 'errstate', 'jn', 'airy', 'airye', 'bei', 'beip', 'ber', 'berp', 'binom', 'exp1', 'expi', 'expit', 'exprel', 'gamma', 'gammaln', 'hankel1', 'hankel1e', 'hankel2', 'hankel2e', 'hyp2f1', 'it2i0k0', 'it2j0y0', 'it2struve0', 'itairy', 'iti0k0', 'itj0y0', 'itmodstruve0', 'itstruve0', 'iv', 'ive', 'jv', 'jve', 'kei', 'keip', 'kelvin', 'ker', 'kerp', 'kv', 'kve', 'log_expit', 'log_wright_bessel', 'loggamma', 'logit', 'mathieu_a', 'mathieu_b', 'mathieu_cem', 'mathieu_modcem1', 'mathieu_modcem2', 'mathieu_modsem1', 'mathieu_modsem2', 'mathieu_sem', 'modfresnelm', 'modfresnelp', 'obl_ang1', 'obl_ang1_cv', 'obl_cv', 'obl_rad1', 'obl_rad1_cv', 'obl_rad2', 'obl_rad2_cv', 'pbdv', 'pbvv', 'pbwa', 'pro_ang1', 'pro_ang1_cv', 'pro_cv', 'pro_rad1', 'pro_rad1_cv', 'pro_rad2', 'pro_rad2_cv', 'psi', 'rgamma', 'sph_harm', 'wright_bessel', 'yv', 'yve']
cdef void loop_D_DDDD__As_DDDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0], <double complex>(<double complex*>ip2)[0], <double complex>(<double complex*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDDD__As_FFFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0], <double complex>(<float complex*>ip2)[0], <double complex>(<float complex*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDD__As_DDD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0], <double complex>(<double complex*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_DDD__As_FFF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0], <double complex>(<float complex*>ip2)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_DD__As_DD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_DD__As_FF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex, double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], <double complex>(<float complex*>ip1)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_D__As_D_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_D_D__As_F_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double complex) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_D_dD__As_dD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double complex>(<double complex*>ip1)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_dD__As_fF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double complex>(<float complex*>ip1)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_D_ddD__As_ddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double complex>(<double complex*>ip2)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_ddD__As_ffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double complex>(<float complex*>ip2)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddD__As_dddD_D(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double complex) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double complex>(<double complex*>ip3)[0])
        (<double complex *>op0)[0] = <double complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_D_dddD__As_fffF_F(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double complex ov0
    for i in range(n):
        ov0 = (<double complex(*)(double, double, double, double complex) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double complex>(<float complex*>ip3)[0])
        (<float complex *>op0)[0] = <float complex>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_d__As_d_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double) noexcept nogil>func)(<double>(<double*>ip0)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_d_d__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double) noexcept nogil>func)(<double>(<float*>ip0)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_d_dd__As_dd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_dd__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddd__As_ddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddd__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd__As_dddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_dddd__As_ffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddddddd__As_ddddddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0], <double>(<double*>ip4)[0], <double>(<double*>ip5)[0], <double>(<double*>ip6)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddddddd__As_fffffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, double, double, double, double, double, double) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], <double>(<float*>ip2)[0], <double>(<float*>ip3)[0], <double>(<float*>ip4)[0], <double>(<float*>ip5)[0], <double>(<float*>ip6)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddiiddd__As_ddllddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *ip4 = args[4]
    cdef char *ip5 = args[5]
    cdef char *ip6 = args[6]
    cdef char *op0 = args[7]
    cdef double ov0
    for i in range(n):
        if <int>(<long*>ip2)[0] == (<long*>ip2)[0] and <int>(<long*>ip3)[0] == (<long*>ip3)[0]:
            ov0 = (<double(*)(double, double, int, int, double, double, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <int>(<long*>ip2)[0], <int>(<long*>ip3)[0], <double>(<double*>ip4)[0], <double>(<double*>ip5)[0], <double>(<double*>ip6)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <double>NAN
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        ip4 += steps[4]
        ip5 += steps[5]
        ip6 += steps[6]
        op0 += steps[7]
    sf_error.check_fpe(func_name)

cdef void loop_d_ddp_d_As_ddp_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef char *op1 = args[4]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        ov0 = (<double(*)(double, double, Py_ssize_t, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], <Py_ssize_t>(<Py_ssize_t*>ip2)[0], &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
        op1 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_dpd__As_dpd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(double, Py_ssize_t, double) noexcept nogil>func)(<double>(<double*>ip0)[0], <Py_ssize_t>(<Py_ssize_t*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_pd__As_pd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(Py_ssize_t, double) noexcept nogil>func)(<Py_ssize_t>(<Py_ssize_t*>ip0)[0], <double>(<double*>ip1)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_d_pdd__As_pdd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(Py_ssize_t, double, double) noexcept nogil>func)(<Py_ssize_t>(<Py_ssize_t*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_d_pddd__As_pddd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(Py_ssize_t, double, double, double) noexcept nogil>func)(<Py_ssize_t>(<Py_ssize_t*>ip0)[0], <double>(<double*>ip1)[0], <double>(<double*>ip2)[0], <double>(<double*>ip3)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_d_ppd__As_ppd_d(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef double ov0
    for i in range(n):
        ov0 = (<double(*)(Py_ssize_t, Py_ssize_t, double) noexcept nogil>func)(<Py_ssize_t>(<Py_ssize_t*>ip0)[0], <Py_ssize_t>(<Py_ssize_t*>ip1)[0], <double>(<double*>ip2)[0])
        (<double *>op0)[0] = <double>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_f_f__As_f_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float) noexcept nogil>func)(<float>(<float*>ip0)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef void loop_f_ff__As_ff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float, float) noexcept nogil>func)(<float>(<float*>ip0)[0], <float>(<float*>ip1)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_f_fff__As_fff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *op0 = args[3]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float, float, float) noexcept nogil>func)(<float>(<float*>ip0)[0], <float>(<float*>ip1)[0], <float>(<float*>ip2)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        op0 += steps[3]
    sf_error.check_fpe(func_name)

cdef void loop_f_ffff__As_ffff_f(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *ip2 = args[2]
    cdef char *ip3 = args[3]
    cdef char *op0 = args[4]
    cdef float ov0
    for i in range(n):
        ov0 = (<float(*)(float, float, float, float) noexcept nogil>func)(<float>(<float*>ip0)[0], <float>(<float*>ip1)[0], <float>(<float*>ip2)[0], <float>(<float*>ip3)[0])
        (<float *>op0)[0] = <float>ov0
        ip0 += steps[0]
        ip1 += steps[1]
        ip2 += steps[2]
        ip3 += steps[3]
        op0 += steps[4]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DD_As_D_DD(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *) noexcept nogil>func)(<double complex>(<double complex*>ip0)[0], &ov0, &ov1)
        (<double complex *>op0)[0] = <double complex>ov0
        (<double complex *>op1)[0] = <double complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_D_DD_As_F_FF(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double complex ov0
    cdef double complex ov1
    for i in range(n):
        (<int(*)(double complex, double complex *, double complex *) noexcept nogil>func)(<double complex>(<float complex*>ip0)[0], &ov0, &ov1)
        (<float complex *>op0)[0] = <float complex>ov0
        (<float complex *>op1)[0] = <float complex>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dd_As_d_dd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], &ov0, &ov1)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_d_dd_As_f_ff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef char *op1 = args[2]
    cdef double ov0
    cdef double ov1
    for i in range(n):
        (<int(*)(double, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], &ov0, &ov1)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        ip0 += steps[0]
        op0 += steps[1]
        op1 += steps[2]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dddd_As_dd_dddd(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef char *op2 = args[4]
    cdef char *op3 = args[5]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double, double *, double *, double *, double *) noexcept nogil>func)(<double>(<double*>ip0)[0], <double>(<double*>ip1)[0], &ov0, &ov1, &ov2, &ov3)
        (<double *>op0)[0] = <double>ov0
        (<double *>op1)[0] = <double>ov1
        (<double *>op2)[0] = <double>ov2
        (<double *>op3)[0] = <double>ov3
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
        op2 += steps[4]
        op3 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_i_dd_dddd_As_ff_ffff(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *ip1 = args[1]
    cdef char *op0 = args[2]
    cdef char *op1 = args[3]
    cdef char *op2 = args[4]
    cdef char *op3 = args[5]
    cdef double ov0
    cdef double ov1
    cdef double ov2
    cdef double ov3
    for i in range(n):
        (<int(*)(double, double, double *, double *, double *, double *) noexcept nogil>func)(<double>(<float*>ip0)[0], <double>(<float*>ip1)[0], &ov0, &ov1, &ov2, &ov3)
        (<float *>op0)[0] = <float>ov0
        (<float *>op1)[0] = <float>ov1
        (<float *>op2)[0] = <float>ov2
        (<float *>op3)[0] = <float>ov3
        ip0 += steps[0]
        ip1 += steps[1]
        op0 += steps[2]
        op1 += steps[3]
        op2 += steps[4]
        op3 += steps[5]
    sf_error.check_fpe(func_name)

cdef void loop_i_i__As_l_l(char **args, np.npy_intp *dims, np.npy_intp *steps, void *data) noexcept nogil:
    cdef np.npy_intp i, n = dims[0]
    cdef void *func = (<void**>data)[0]
    cdef char *func_name = <char*>(<void**>data)[1]
    cdef char *ip0 = args[0]
    cdef char *op0 = args[1]
    cdef int ov0
    for i in range(n):
        if <int>(<long*>ip0)[0] == (<long*>ip0)[0]:
            ov0 = (<int(*)(int) noexcept nogil>func)(<int>(<long*>ip0)[0])
        else:
            sf_error.error(func_name, sf_error.DOMAIN, "invalid input argument")
            ov0 = <int>0xbad0bad0
        (<long *>op0)[0] = <long>ov0
        ip0 += steps[0]
        op0 += steps[1]
    sf_error.check_fpe(func_name)

cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosine_cdf "cosine_cdf"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cosine_invcdf "cosine_invcdf"(double) noexcept nogil
from ._ellip_harm cimport ellip_harmonic as _func_ellip_harmonic
ctypedef double _proto_ellip_harmonic_t(double, double, int, int, double, double, double) noexcept nogil
cdef _proto_ellip_harmonic_t *_proto_ellip_harmonic_t_var = &_func_ellip_harmonic
from ._legacy cimport ellip_harmonic_unsafe as _func_ellip_harmonic_unsafe
ctypedef double _proto_ellip_harmonic_unsafe_t(double, double, double, double, double, double, double) noexcept nogil
cdef _proto_ellip_harmonic_unsafe_t *_proto_ellip_harmonic_unsafe_t_var = &_func_ellip_harmonic_unsafe
from ._factorial cimport _factorial as _func__factorial
ctypedef double _proto__factorial_t(double) noexcept nogil
cdef _proto__factorial_t *_proto__factorial_t_var = &_func__factorial
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_igam_fac "cephes_igam_fac"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_kolmogc "cephes_kolmogc"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_kolmogci "cephes_kolmogci"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_kolmogp "cephes_kolmogp"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_lanczos_sum_expg_scaled "cephes_lanczos_sum_expg_scaled"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_lgam1p "cephes_lgam1p"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_log1pmx "cephes_log1pmx"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_riemann_zeta "cephes_riemann_zeta"(double) noexcept nogil
from .sf_error cimport _sf_error_test_function as _func__sf_error_test_function
ctypedef int _proto__sf_error_test_function_t(int) noexcept nogil
cdef _proto__sf_error_test_function_t *_proto__sf_error_test_function_t_var = &_func__sf_error_test_function
from ._legacy cimport smirnovc_unsafe as _func_smirnovc_unsafe
ctypedef double _proto_smirnovc_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovc_unsafe_t *_proto_smirnovc_unsafe_t_var = &_func_smirnovc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_smirnovc_wrap "cephes_smirnovc_wrap"(Py_ssize_t, double) noexcept nogil
from ._legacy cimport smirnovci_unsafe as _func_smirnovci_unsafe
ctypedef double _proto_smirnovci_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovci_unsafe_t *_proto_smirnovci_unsafe_t_var = &_func_smirnovci_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_smirnovci_wrap "cephes_smirnovci_wrap"(Py_ssize_t, double) noexcept nogil
from ._legacy cimport smirnovp_unsafe as _func_smirnovp_unsafe
ctypedef double _proto_smirnovp_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovp_unsafe_t *_proto_smirnovp_unsafe_t_var = &_func_smirnovp_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_smirnovp_wrap "cephes_smirnovp_wrap"(Py_ssize_t, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes__struve_asymp_large_z "cephes__struve_asymp_large_z"(double, double, Py_ssize_t, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes__struve_bessel_series "cephes__struve_bessel_series"(double, double, Py_ssize_t, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes__struve_power_series "cephes__struve_power_series"(double, double, Py_ssize_t, double *) noexcept nogil
from ._agm cimport agm as _func_agm
ctypedef double _proto_agm_t(double, double) noexcept nogil
cdef _proto_agm_t *_proto_agm_t_var = &_func_agm
from ._legacy cimport bdtr_unsafe as _func_bdtr_unsafe
ctypedef double _proto_bdtr_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtr_unsafe_t *_proto_bdtr_unsafe_t_var = &_func_bdtr_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_bdtr_wrap "cephes_bdtr_wrap"(double, Py_ssize_t, double) noexcept nogil
from ._legacy cimport bdtrc_unsafe as _func_bdtrc_unsafe
ctypedef double _proto_bdtrc_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtrc_unsafe_t *_proto_bdtrc_unsafe_t_var = &_func_bdtrc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_bdtrc_wrap "cephes_bdtrc_wrap"(double, Py_ssize_t, double) noexcept nogil
from ._legacy cimport bdtri_unsafe as _func_bdtri_unsafe
ctypedef double _proto_bdtri_unsafe_t(double, double, double) noexcept nogil
cdef _proto_bdtri_unsafe_t *_proto_bdtri_unsafe_t_var = &_func_bdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_bdtri_wrap "cephes_bdtri_wrap"(double, Py_ssize_t, double) noexcept nogil
from ._cdflib_wrappers cimport bdtrik as _func_bdtrik
ctypedef double _proto_bdtrik_t(double, double, double) noexcept nogil
cdef _proto_bdtrik_t *_proto_bdtrik_t_var = &_func_bdtrik
from ._cdflib_wrappers cimport bdtrin as _func_bdtrin
ctypedef double _proto_bdtrin_t(double, double, double) noexcept nogil
cdef _proto_bdtrin_t *_proto_bdtrin_t_var = &_func_bdtrin
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_besselpoly "cephes_besselpoly"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_beta "cephes_beta"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_lbeta "cephes_lbeta"(double, double) noexcept nogil
from ._boxcox cimport boxcox as _func_boxcox
ctypedef double _proto_boxcox_t(double, double) noexcept nogil
cdef _proto_boxcox_t *_proto_boxcox_t_var = &_func_boxcox
from ._boxcox cimport boxcox1p as _func_boxcox1p
ctypedef double _proto_boxcox1p_t(double, double) noexcept nogil
cdef _proto_boxcox1p_t *_proto_boxcox1p_t_var = &_func_boxcox1p
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_btdtr "cephes_btdtr"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_btdtri "cephes_btdtri"(double, double, double) noexcept nogil
from ._cdflib_wrappers cimport btdtria as _func_btdtria
ctypedef double _proto_btdtria_t(double, double, double) noexcept nogil
cdef _proto_btdtria_t *_proto_btdtria_t_var = &_func_btdtria
from ._cdflib_wrappers cimport btdtrib as _func_btdtrib
ctypedef double _proto_btdtrib_t(double, double, double) noexcept nogil
cdef _proto_btdtrib_t *_proto_btdtrib_t_var = &_func_btdtrib
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_cbrt "cephes_cbrt"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_chdtr "cephes_chdtr"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_chdtrc "cephes_chdtrc"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_chdtri "cephes_chdtri"(double, double) noexcept nogil
from ._cdflib_wrappers cimport chdtriv as _func_chdtriv
ctypedef double _proto_chdtriv_t(double, double) noexcept nogil
cdef _proto_chdtriv_t *_proto_chdtriv_t_var = &_func_chdtriv
from ._cdflib_wrappers cimport chndtr as _func_chndtr
ctypedef double _proto_chndtr_t(double, double, double) noexcept nogil
cdef _proto_chndtr_t *_proto_chndtr_t_var = &_func_chndtr
from ._cdflib_wrappers cimport chndtridf as _func_chndtridf
ctypedef double _proto_chndtridf_t(double, double, double) noexcept nogil
cdef _proto_chndtridf_t *_proto_chndtridf_t_var = &_func_chndtridf
from ._cdflib_wrappers cimport chndtrinc as _func_chndtrinc
ctypedef double _proto_chndtrinc_t(double, double, double) noexcept nogil
cdef _proto_chndtrinc_t *_proto_chndtrinc_t_var = &_func_chndtrinc
from ._cdflib_wrappers cimport chndtrix as _func_chndtrix
ctypedef double _proto_chndtrix_t(double, double, double) noexcept nogil
cdef _proto_chndtrix_t *_proto_chndtrix_t_var = &_func_chndtrix
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_cosdg "cephes_cosdg"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_cosm1 "cephes_cosm1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_cotdg "cephes_cotdg"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_ellpe "cephes_ellpe"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_ellie "cephes_ellie"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cephes_ellpj_wrap "cephes_ellpj_wrap"(double, double, double *, double *, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_special_ellipk "special_ellipk"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_ellik "cephes_ellik"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_ellpk "cephes_ellpk"(double) noexcept nogil
from ._convex_analysis cimport entr as _func_entr
ctypedef double _proto_entr_t(double) noexcept nogil
cdef _proto_entr_t *_proto_entr_t_var = &_func_entr
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_erf "cephes_erf"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_erfc "cephes_erfc"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_erfcinv "cephes_erfcinv"(double) noexcept nogil
from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc
ctypedef double complex _proto_eval_chebyc_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyc_double_complex__t *_proto_eval_chebyc_double_complex__t_var = &_func_eval_chebyc[double_complex]
from .orthogonal_eval cimport eval_chebyc as _func_eval_chebyc
ctypedef double _proto_eval_chebyc_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyc_double__t *_proto_eval_chebyc_double__t_var = &_func_eval_chebyc[double]
from .orthogonal_eval cimport eval_chebyc_l as _func_eval_chebyc_l
ctypedef double _proto_eval_chebyc_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_chebyc_l_t *_proto_eval_chebyc_l_t_var = &_func_eval_chebyc_l
from .orthogonal_eval cimport eval_chebys as _func_eval_chebys
ctypedef double complex _proto_eval_chebys_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebys_double_complex__t *_proto_eval_chebys_double_complex__t_var = &_func_eval_chebys[double_complex]
from .orthogonal_eval cimport eval_chebys as _func_eval_chebys
ctypedef double _proto_eval_chebys_double__t(double, double) noexcept nogil
cdef _proto_eval_chebys_double__t *_proto_eval_chebys_double__t_var = &_func_eval_chebys[double]
from .orthogonal_eval cimport eval_chebys_l as _func_eval_chebys_l
ctypedef double _proto_eval_chebys_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_chebys_l_t *_proto_eval_chebys_l_t_var = &_func_eval_chebys_l
from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt
ctypedef double complex _proto_eval_chebyt_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyt_double_complex__t *_proto_eval_chebyt_double_complex__t_var = &_func_eval_chebyt[double_complex]
from .orthogonal_eval cimport eval_chebyt as _func_eval_chebyt
ctypedef double _proto_eval_chebyt_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyt_double__t *_proto_eval_chebyt_double__t_var = &_func_eval_chebyt[double]
from .orthogonal_eval cimport eval_chebyt_l as _func_eval_chebyt_l
ctypedef double _proto_eval_chebyt_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_chebyt_l_t *_proto_eval_chebyt_l_t_var = &_func_eval_chebyt_l
from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu
ctypedef double complex _proto_eval_chebyu_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_chebyu_double_complex__t *_proto_eval_chebyu_double_complex__t_var = &_func_eval_chebyu[double_complex]
from .orthogonal_eval cimport eval_chebyu as _func_eval_chebyu
ctypedef double _proto_eval_chebyu_double__t(double, double) noexcept nogil
cdef _proto_eval_chebyu_double__t *_proto_eval_chebyu_double__t_var = &_func_eval_chebyu[double]
from .orthogonal_eval cimport eval_chebyu_l as _func_eval_chebyu_l
ctypedef double _proto_eval_chebyu_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_chebyu_l_t *_proto_eval_chebyu_l_t_var = &_func_eval_chebyu_l
from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer
ctypedef double complex _proto_eval_gegenbauer_double_complex__t(double, double, double complex) noexcept nogil
cdef _proto_eval_gegenbauer_double_complex__t *_proto_eval_gegenbauer_double_complex__t_var = &_func_eval_gegenbauer[double_complex]
from .orthogonal_eval cimport eval_gegenbauer as _func_eval_gegenbauer
ctypedef double _proto_eval_gegenbauer_double__t(double, double, double) noexcept nogil
cdef _proto_eval_gegenbauer_double__t *_proto_eval_gegenbauer_double__t_var = &_func_eval_gegenbauer[double]
from .orthogonal_eval cimport eval_gegenbauer_l as _func_eval_gegenbauer_l
ctypedef double _proto_eval_gegenbauer_l_t(Py_ssize_t, double, double) noexcept nogil
cdef _proto_eval_gegenbauer_l_t *_proto_eval_gegenbauer_l_t_var = &_func_eval_gegenbauer_l
from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre
ctypedef double complex _proto_eval_genlaguerre_double_complex__t(double, double, double complex) noexcept nogil
cdef _proto_eval_genlaguerre_double_complex__t *_proto_eval_genlaguerre_double_complex__t_var = &_func_eval_genlaguerre[double_complex]
from .orthogonal_eval cimport eval_genlaguerre as _func_eval_genlaguerre
ctypedef double _proto_eval_genlaguerre_double__t(double, double, double) noexcept nogil
cdef _proto_eval_genlaguerre_double__t *_proto_eval_genlaguerre_double__t_var = &_func_eval_genlaguerre[double]
from .orthogonal_eval cimport eval_genlaguerre_l as _func_eval_genlaguerre_l
ctypedef double _proto_eval_genlaguerre_l_t(Py_ssize_t, double, double) noexcept nogil
cdef _proto_eval_genlaguerre_l_t *_proto_eval_genlaguerre_l_t_var = &_func_eval_genlaguerre_l
from .orthogonal_eval cimport eval_hermite as _func_eval_hermite
ctypedef double _proto_eval_hermite_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_hermite_t *_proto_eval_hermite_t_var = &_func_eval_hermite
from .orthogonal_eval cimport eval_hermitenorm as _func_eval_hermitenorm
ctypedef double _proto_eval_hermitenorm_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_hermitenorm_t *_proto_eval_hermitenorm_t_var = &_func_eval_hermitenorm
from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi
ctypedef double complex _proto_eval_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil
cdef _proto_eval_jacobi_double_complex__t *_proto_eval_jacobi_double_complex__t_var = &_func_eval_jacobi[double_complex]
from .orthogonal_eval cimport eval_jacobi as _func_eval_jacobi
ctypedef double _proto_eval_jacobi_double__t(double, double, double, double) noexcept nogil
cdef _proto_eval_jacobi_double__t *_proto_eval_jacobi_double__t_var = &_func_eval_jacobi[double]
from .orthogonal_eval cimport eval_jacobi_l as _func_eval_jacobi_l
ctypedef double _proto_eval_jacobi_l_t(Py_ssize_t, double, double, double) noexcept nogil
cdef _proto_eval_jacobi_l_t *_proto_eval_jacobi_l_t_var = &_func_eval_jacobi_l
from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre
ctypedef double complex _proto_eval_laguerre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_laguerre_double_complex__t *_proto_eval_laguerre_double_complex__t_var = &_func_eval_laguerre[double_complex]
from .orthogonal_eval cimport eval_laguerre as _func_eval_laguerre
ctypedef double _proto_eval_laguerre_double__t(double, double) noexcept nogil
cdef _proto_eval_laguerre_double__t *_proto_eval_laguerre_double__t_var = &_func_eval_laguerre[double]
from .orthogonal_eval cimport eval_laguerre_l as _func_eval_laguerre_l
ctypedef double _proto_eval_laguerre_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_laguerre_l_t *_proto_eval_laguerre_l_t_var = &_func_eval_laguerre_l
from .orthogonal_eval cimport eval_legendre as _func_eval_legendre
ctypedef double complex _proto_eval_legendre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_legendre_double_complex__t *_proto_eval_legendre_double_complex__t_var = &_func_eval_legendre[double_complex]
from .orthogonal_eval cimport eval_legendre as _func_eval_legendre
ctypedef double _proto_eval_legendre_double__t(double, double) noexcept nogil
cdef _proto_eval_legendre_double__t *_proto_eval_legendre_double__t_var = &_func_eval_legendre[double]
from .orthogonal_eval cimport eval_legendre_l as _func_eval_legendre_l
ctypedef double _proto_eval_legendre_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_legendre_l_t *_proto_eval_legendre_l_t_var = &_func_eval_legendre_l
from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt
ctypedef double complex _proto_eval_sh_chebyt_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_chebyt_double_complex__t *_proto_eval_sh_chebyt_double_complex__t_var = &_func_eval_sh_chebyt[double_complex]
from .orthogonal_eval cimport eval_sh_chebyt as _func_eval_sh_chebyt
ctypedef double _proto_eval_sh_chebyt_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_chebyt_double__t *_proto_eval_sh_chebyt_double__t_var = &_func_eval_sh_chebyt[double]
from .orthogonal_eval cimport eval_sh_chebyt_l as _func_eval_sh_chebyt_l
ctypedef double _proto_eval_sh_chebyt_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_sh_chebyt_l_t *_proto_eval_sh_chebyt_l_t_var = &_func_eval_sh_chebyt_l
from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu
ctypedef double complex _proto_eval_sh_chebyu_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_chebyu_double_complex__t *_proto_eval_sh_chebyu_double_complex__t_var = &_func_eval_sh_chebyu[double_complex]
from .orthogonal_eval cimport eval_sh_chebyu as _func_eval_sh_chebyu
ctypedef double _proto_eval_sh_chebyu_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_chebyu_double__t *_proto_eval_sh_chebyu_double__t_var = &_func_eval_sh_chebyu[double]
from .orthogonal_eval cimport eval_sh_chebyu_l as _func_eval_sh_chebyu_l
ctypedef double _proto_eval_sh_chebyu_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_sh_chebyu_l_t *_proto_eval_sh_chebyu_l_t_var = &_func_eval_sh_chebyu_l
from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi
ctypedef double complex _proto_eval_sh_jacobi_double_complex__t(double, double, double, double complex) noexcept nogil
cdef _proto_eval_sh_jacobi_double_complex__t *_proto_eval_sh_jacobi_double_complex__t_var = &_func_eval_sh_jacobi[double_complex]
from .orthogonal_eval cimport eval_sh_jacobi as _func_eval_sh_jacobi
ctypedef double _proto_eval_sh_jacobi_double__t(double, double, double, double) noexcept nogil
cdef _proto_eval_sh_jacobi_double__t *_proto_eval_sh_jacobi_double__t_var = &_func_eval_sh_jacobi[double]
from .orthogonal_eval cimport eval_sh_jacobi_l as _func_eval_sh_jacobi_l
ctypedef double _proto_eval_sh_jacobi_l_t(Py_ssize_t, double, double, double) noexcept nogil
cdef _proto_eval_sh_jacobi_l_t *_proto_eval_sh_jacobi_l_t_var = &_func_eval_sh_jacobi_l
from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre
ctypedef double complex _proto_eval_sh_legendre_double_complex__t(double, double complex) noexcept nogil
cdef _proto_eval_sh_legendre_double_complex__t *_proto_eval_sh_legendre_double_complex__t_var = &_func_eval_sh_legendre[double_complex]
from .orthogonal_eval cimport eval_sh_legendre as _func_eval_sh_legendre
ctypedef double _proto_eval_sh_legendre_double__t(double, double) noexcept nogil
cdef _proto_eval_sh_legendre_double__t *_proto_eval_sh_legendre_double__t_var = &_func_eval_sh_legendre[double]
from .orthogonal_eval cimport eval_sh_legendre_l as _func_eval_sh_legendre_l
ctypedef double _proto_eval_sh_legendre_l_t(Py_ssize_t, double) noexcept nogil
cdef _proto_eval_sh_legendre_l_t *_proto_eval_sh_legendre_l_t_var = &_func_eval_sh_legendre_l
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_exp10 "cephes_exp10"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_exp2 "cephes_exp2"(double) noexcept nogil
from ._cunity cimport cexpm1 as _func_cexpm1
ctypedef double complex _proto_cexpm1_t(double complex) noexcept nogil
cdef _proto_cexpm1_t *_proto_cexpm1_t_var = &_func_cexpm1
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_expm1 "cephes_expm1"(double) noexcept nogil
from ._legacy cimport expn_unsafe as _func_expn_unsafe
ctypedef double _proto_expn_unsafe_t(double, double) noexcept nogil
cdef _proto_expn_unsafe_t *_proto_expn_unsafe_t_var = &_func_expn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_expn_wrap "cephes_expn_wrap"(Py_ssize_t, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_fdtr "cephes_fdtr"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_fdtrc "cephes_fdtrc"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_fdtri "cephes_fdtri"(double, double, double) noexcept nogil
from ._cdflib_wrappers cimport fdtridfd as _func_fdtridfd
ctypedef double _proto_fdtridfd_t(double, double, double) noexcept nogil
cdef _proto_fdtridfd_t *_proto_fdtridfd_t_var = &_func_fdtridfd
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cephes_fresnl_wrap "cephes_fresnl_wrap"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cfresnl_wrap "cfresnl_wrap"(double complex, double complex *, double complex *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_igam "cephes_igam"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_igamc "cephes_igamc"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_igamci "cephes_igamci"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_igami "cephes_igami"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_gammasgn "cephes_gammasgn"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_gdtr "cephes_gdtr"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_gdtrc "cephes_gdtrc"(double, double, double) noexcept nogil
from ._cdflib_wrappers cimport gdtria as _func_gdtria
ctypedef double _proto_gdtria_t(double, double, double) noexcept nogil
cdef _proto_gdtria_t *_proto_gdtria_t_var = &_func_gdtria
from ._cdflib_wrappers cimport gdtrib as _func_gdtrib
ctypedef double _proto_gdtrib_t(double, double, double) noexcept nogil
cdef _proto_gdtrib_t *_proto_gdtrib_t_var = &_func_gdtrib
from ._cdflib_wrappers cimport gdtrix as _func_gdtrix
ctypedef double _proto_gdtrix_t(double, double, double) noexcept nogil
cdef _proto_gdtrix_t *_proto_gdtrix_t_var = &_func_gdtrix
from ._convex_analysis cimport huber as _func_huber
ctypedef double _proto_huber_t(double, double) noexcept nogil
cdef _proto_huber_t *_proto_huber_t_var = &_func_huber
from ._hyp0f1 cimport _hyp0f1_cmplx as _func__hyp0f1_cmplx
ctypedef double complex _proto__hyp0f1_cmplx_t(double, double complex) noexcept nogil
cdef _proto__hyp0f1_cmplx_t *_proto__hyp0f1_cmplx_t_var = &_func__hyp0f1_cmplx
from ._hyp0f1 cimport _hyp0f1_real as _func__hyp0f1_real
ctypedef double _proto__hyp0f1_real_t(double, double) noexcept nogil
cdef _proto__hyp0f1_real_t *_proto__hyp0f1_real_t_var = &_func__hyp0f1_real
cdef extern from r"_ufuncs_defs.h":
    cdef double complex _func_chyp1f1_wrap "chyp1f1_wrap"(double, double, double complex) noexcept nogil
from ._hypergeometric cimport hyperu as _func_hyperu
ctypedef double _proto_hyperu_t(double, double, double) noexcept nogil
cdef _proto_hyperu_t *_proto_hyperu_t_var = &_func_hyperu
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_i0 "cephes_i0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_i0e "cephes_i0e"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_i1 "cephes_i1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_i1e "cephes_i1e"(double) noexcept nogil
from ._boxcox cimport inv_boxcox as _func_inv_boxcox
ctypedef double _proto_inv_boxcox_t(double, double) noexcept nogil
cdef _proto_inv_boxcox_t *_proto_inv_boxcox_t_var = &_func_inv_boxcox
from ._boxcox cimport inv_boxcox1p as _func_inv_boxcox1p
ctypedef double _proto_inv_boxcox1p_t(double, double) noexcept nogil
cdef _proto_inv_boxcox1p_t *_proto_inv_boxcox1p_t_var = &_func_inv_boxcox1p
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_j0 "cephes_j0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_j1 "cephes_j1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_k0 "cephes_k0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_k0e "cephes_k0e"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_k1 "cephes_k1"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_k1e "cephes_k1e"(double) noexcept nogil
from ._convex_analysis cimport kl_div as _func_kl_div
ctypedef double _proto_kl_div_t(double, double) noexcept nogil
cdef _proto_kl_div_t *_proto_kl_div_t_var = &_func_kl_div
from ._legacy cimport kn_unsafe as _func_kn_unsafe
ctypedef double _proto_kn_unsafe_t(double, double) noexcept nogil
cdef _proto_kn_unsafe_t *_proto_kn_unsafe_t_var = &_func_kn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_special_cyl_bessel_k_int "special_cyl_bessel_k_int"(Py_ssize_t, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_kolmogi "cephes_kolmogi"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_kolmogorov "cephes_kolmogorov"(double) noexcept nogil
from ._cunity cimport clog1p as _func_clog1p
ctypedef double complex _proto_clog1p_t(double complex) noexcept nogil
cdef _proto_clog1p_t *_proto_clog1p_t_var = &_func_clog1p
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_log1p "cephes_log1p"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_pmv_wrap "pmv_wrap"(double, double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_struve_l "cephes_struve_l"(double, double) noexcept nogil
from ._legacy cimport nbdtr_unsafe as _func_nbdtr_unsafe
ctypedef double _proto_nbdtr_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtr_unsafe_t *_proto_nbdtr_unsafe_t_var = &_func_nbdtr_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_nbdtr_wrap "cephes_nbdtr_wrap"(Py_ssize_t, Py_ssize_t, double) noexcept nogil
from ._legacy cimport nbdtrc_unsafe as _func_nbdtrc_unsafe
ctypedef double _proto_nbdtrc_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtrc_unsafe_t *_proto_nbdtrc_unsafe_t_var = &_func_nbdtrc_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_nbdtrc_wrap "cephes_nbdtrc_wrap"(Py_ssize_t, Py_ssize_t, double) noexcept nogil
from ._legacy cimport nbdtri_unsafe as _func_nbdtri_unsafe
ctypedef double _proto_nbdtri_unsafe_t(double, double, double) noexcept nogil
cdef _proto_nbdtri_unsafe_t *_proto_nbdtri_unsafe_t_var = &_func_nbdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_nbdtri_wrap "cephes_nbdtri_wrap"(Py_ssize_t, Py_ssize_t, double) noexcept nogil
from ._cdflib_wrappers cimport nbdtrik as _func_nbdtrik
ctypedef double _proto_nbdtrik_t(double, double, double) noexcept nogil
cdef _proto_nbdtrik_t *_proto_nbdtrik_t_var = &_func_nbdtrik
from ._cdflib_wrappers cimport nbdtrin as _func_nbdtrin
ctypedef double _proto_nbdtrin_t(double, double, double) noexcept nogil
cdef _proto_nbdtrin_t *_proto_nbdtrin_t_var = &_func_nbdtrin
from ._cdflib_wrappers cimport ncfdtr as _func_ncfdtr
ctypedef double _proto_ncfdtr_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtr_t *_proto_ncfdtr_t_var = &_func_ncfdtr
from ._cdflib_wrappers cimport ncfdtri as _func_ncfdtri
ctypedef double _proto_ncfdtri_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtri_t *_proto_ncfdtri_t_var = &_func_ncfdtri
from ._cdflib_wrappers cimport ncfdtridfd as _func_ncfdtridfd
ctypedef double _proto_ncfdtridfd_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtridfd_t *_proto_ncfdtridfd_t_var = &_func_ncfdtridfd
from ._cdflib_wrappers cimport ncfdtridfn as _func_ncfdtridfn
ctypedef double _proto_ncfdtridfn_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtridfn_t *_proto_ncfdtridfn_t_var = &_func_ncfdtridfn
from ._cdflib_wrappers cimport ncfdtrinc as _func_ncfdtrinc
ctypedef double _proto_ncfdtrinc_t(double, double, double, double) noexcept nogil
cdef _proto_ncfdtrinc_t *_proto_ncfdtrinc_t_var = &_func_ncfdtrinc
from ._cdflib_wrappers cimport nctdtr as _func_nctdtr
ctypedef double _proto_nctdtr_t(double, double, double) noexcept nogil
cdef _proto_nctdtr_t *_proto_nctdtr_t_var = &_func_nctdtr
from ._cdflib_wrappers cimport nctdtridf as _func_nctdtridf
ctypedef double _proto_nctdtridf_t(double, double, double) noexcept nogil
cdef _proto_nctdtridf_t *_proto_nctdtridf_t_var = &_func_nctdtridf
from ._cdflib_wrappers cimport nctdtrinc as _func_nctdtrinc
ctypedef double _proto_nctdtrinc_t(double, double, double) noexcept nogil
cdef _proto_nctdtrinc_t *_proto_nctdtrinc_t_var = &_func_nctdtrinc
from ._cdflib_wrappers cimport nctdtrit as _func_nctdtrit
ctypedef double _proto_nctdtrit_t(double, double, double) noexcept nogil
cdef _proto_nctdtrit_t *_proto_nctdtrit_t_var = &_func_nctdtrit
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_ndtr "cephes_ndtr"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_ndtri "cephes_ndtri"(double) noexcept nogil
from ._ndtri_exp cimport ndtri_exp as _func_ndtri_exp
ctypedef double _proto_ndtri_exp_t(double) noexcept nogil
cdef _proto_ndtri_exp_t *_proto_ndtri_exp_t_var = &_func_ndtri_exp
from ._cdflib_wrappers cimport nrdtrimn as _func_nrdtrimn
ctypedef double _proto_nrdtrimn_t(double, double, double) noexcept nogil
cdef _proto_nrdtrimn_t *_proto_nrdtrimn_t_var = &_func_nrdtrimn
from ._cdflib_wrappers cimport nrdtrisd as _func_nrdtrisd
ctypedef double _proto_nrdtrisd_t(double, double, double) noexcept nogil
cdef _proto_nrdtrisd_t *_proto_nrdtrisd_t_var = &_func_nrdtrisd
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_owens_t "cephes_owens_t"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_pdtr "cephes_pdtr"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_pdtrc "cephes_pdtrc"(double, double) noexcept nogil
from ._legacy cimport pdtri_unsafe as _func_pdtri_unsafe
ctypedef double _proto_pdtri_unsafe_t(double, double) noexcept nogil
cdef _proto_pdtri_unsafe_t *_proto_pdtri_unsafe_t_var = &_func_pdtri_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_pdtri_wrap "cephes_pdtri_wrap"(Py_ssize_t, double) noexcept nogil
from ._cdflib_wrappers cimport pdtrik as _func_pdtrik
ctypedef double _proto_pdtrik_t(double, double) noexcept nogil
cdef _proto_pdtrik_t *_proto_pdtrik_t_var = &_func_pdtrik
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_poch "cephes_poch"(double, double) noexcept nogil
from ._convex_analysis cimport pseudo_huber as _func_pseudo_huber
ctypedef double _proto_pseudo_huber_t(double, double) noexcept nogil
cdef _proto_pseudo_huber_t *_proto_pseudo_huber_t_var = &_func_pseudo_huber
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_radian "cephes_radian"(double, double, double) noexcept nogil
from ._convex_analysis cimport rel_entr as _func_rel_entr
ctypedef double _proto_rel_entr_t(double, double) noexcept nogil
cdef _proto_rel_entr_t *_proto_rel_entr_t_var = &_func_rel_entr
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_round "cephes_round"(double) noexcept nogil
from ._sici cimport cshichi as _func_cshichi
ctypedef int _proto_cshichi_t(double complex, double complex *, double complex *) noexcept nogil
cdef _proto_cshichi_t *_proto_cshichi_t_var = &_func_cshichi
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cephes_shichi_wrap "cephes_shichi_wrap"(double, double *, double *) noexcept nogil
from ._sici cimport csici as _func_csici
ctypedef int _proto_csici_t(double complex, double complex *, double complex *) noexcept nogil
cdef _proto_csici_t *_proto_csici_t_var = &_func_csici
cdef extern from r"_ufuncs_defs.h":
    cdef int _func_cephes_sici_wrap "cephes_sici_wrap"(double, double *, double *) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_sindg "cephes_sindg"(double) noexcept nogil
from ._legacy cimport smirnov_unsafe as _func_smirnov_unsafe
ctypedef double _proto_smirnov_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnov_unsafe_t *_proto_smirnov_unsafe_t_var = &_func_smirnov_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_smirnov_wrap "cephes_smirnov_wrap"(Py_ssize_t, double) noexcept nogil
from ._legacy cimport smirnovi_unsafe as _func_smirnovi_unsafe
ctypedef double _proto_smirnovi_unsafe_t(double, double) noexcept nogil
cdef _proto_smirnovi_unsafe_t *_proto_smirnovi_unsafe_t_var = &_func_smirnovi_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_smirnovi_wrap "cephes_smirnovi_wrap"(Py_ssize_t, double) noexcept nogil
from ._spence cimport cspence as _func_cspence
ctypedef double complex _proto_cspence_t(double complex) noexcept nogil
cdef _proto_cspence_t *_proto_cspence_t_var = &_func_cspence
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_spence "cephes_spence"(double) noexcept nogil
from ._cdflib_wrappers cimport stdtr as _func_stdtr
ctypedef double _proto_stdtr_t(double, double) noexcept nogil
cdef _proto_stdtr_t *_proto_stdtr_t_var = &_func_stdtr
from ._cdflib_wrappers cimport stdtridf as _func_stdtridf
ctypedef double _proto_stdtridf_t(double, double) noexcept nogil
cdef _proto_stdtridf_t *_proto_stdtridf_t_var = &_func_stdtridf
from ._cdflib_wrappers cimport stdtrit as _func_stdtrit
ctypedef double _proto_stdtrit_t(double, double) noexcept nogil
cdef _proto_stdtrit_t *_proto_stdtrit_t_var = &_func_stdtrit
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_struve_h "cephes_struve_h"(double, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_tandg "cephes_tandg"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_tukeylambdacdf "cephes_tukeylambdacdf"(double, double) noexcept nogil
from ._xlogy cimport xlog1py as _func_xlog1py
ctypedef double _proto_xlog1py_double__t(double, double) noexcept nogil
cdef _proto_xlog1py_double__t *_proto_xlog1py_double__t_var = &_func_xlog1py[double]
from ._xlogy cimport xlog1py as _func_xlog1py
ctypedef double complex _proto_xlog1py_double_complex__t(double complex, double complex) noexcept nogil
cdef _proto_xlog1py_double_complex__t *_proto_xlog1py_double_complex__t_var = &_func_xlog1py[double_complex]
from ._xlogy cimport xlogy as _func_xlogy
ctypedef double _proto_xlogy_double__t(double, double) noexcept nogil
cdef _proto_xlogy_double__t *_proto_xlogy_double__t_var = &_func_xlogy[double]
from ._xlogy cimport xlogy as _func_xlogy
ctypedef double complex _proto_xlogy_double_complex__t(double complex, double complex) noexcept nogil
cdef _proto_xlogy_double_complex__t *_proto_xlogy_double_complex__t_var = &_func_xlogy[double_complex]
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_y0 "cephes_y0"(double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_y1 "cephes_y1"(double) noexcept nogil
from ._legacy cimport yn_unsafe as _func_yn_unsafe
ctypedef double _proto_yn_unsafe_t(double, double) noexcept nogil
cdef _proto_yn_unsafe_t *_proto_yn_unsafe_t_var = &_func_yn_unsafe
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_yn_wrap "cephes_yn_wrap"(Py_ssize_t, double) noexcept nogil
cdef extern from r"_ufuncs_defs.h":
    cdef double _func_cephes_zetac "cephes_zetac"(double) noexcept nogil
cdef np.PyUFuncGenericFunction ufunc__beta_pdf_loops[2]
cdef void *ufunc__beta_pdf_ptr[4]
cdef void *ufunc__beta_pdf_data[2]
cdef char ufunc__beta_pdf_types[8]
cdef char *ufunc__beta_pdf_doc = (
    "_beta_pdf(x, a, b)\n"
    "\n"
    "Probability density function of beta distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__beta_pdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__beta_pdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__beta_pdf_types[0] = <char>NPY_FLOAT
ufunc__beta_pdf_types[1] = <char>NPY_FLOAT
ufunc__beta_pdf_types[2] = <char>NPY_FLOAT
ufunc__beta_pdf_types[3] = <char>NPY_FLOAT
ufunc__beta_pdf_types[4] = <char>NPY_DOUBLE
ufunc__beta_pdf_types[5] = <char>NPY_DOUBLE
ufunc__beta_pdf_types[6] = <char>NPY_DOUBLE
ufunc__beta_pdf_types[7] = <char>NPY_DOUBLE
ufunc__beta_pdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_beta_pdf_float
ufunc__beta_pdf_ptr[2*0+1] = <void*>(<char*>"_beta_pdf")
ufunc__beta_pdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_beta_pdf_double
ufunc__beta_pdf_ptr[2*1+1] = <void*>(<char*>"_beta_pdf")
ufunc__beta_pdf_data[0] = &ufunc__beta_pdf_ptr[2*0]
ufunc__beta_pdf_data[1] = &ufunc__beta_pdf_ptr[2*1]
_beta_pdf = np.PyUFunc_FromFuncAndData(ufunc__beta_pdf_loops, ufunc__beta_pdf_data, ufunc__beta_pdf_types, 2, 3, 1, 0, "_beta_pdf", ufunc__beta_pdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__beta_ppf_loops[2]
cdef void *ufunc__beta_ppf_ptr[4]
cdef void *ufunc__beta_ppf_data[2]
cdef char ufunc__beta_ppf_types[8]
cdef char *ufunc__beta_ppf_doc = (
    "_beta_ppf(x, a, b)\n"
    "\n"
    "Percent point function of beta distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__beta_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__beta_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__beta_ppf_types[0] = <char>NPY_FLOAT
ufunc__beta_ppf_types[1] = <char>NPY_FLOAT
ufunc__beta_ppf_types[2] = <char>NPY_FLOAT
ufunc__beta_ppf_types[3] = <char>NPY_FLOAT
ufunc__beta_ppf_types[4] = <char>NPY_DOUBLE
ufunc__beta_ppf_types[5] = <char>NPY_DOUBLE
ufunc__beta_ppf_types[6] = <char>NPY_DOUBLE
ufunc__beta_ppf_types[7] = <char>NPY_DOUBLE
ufunc__beta_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_beta_ppf_float
ufunc__beta_ppf_ptr[2*0+1] = <void*>(<char*>"_beta_ppf")
ufunc__beta_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_beta_ppf_double
ufunc__beta_ppf_ptr[2*1+1] = <void*>(<char*>"_beta_ppf")
ufunc__beta_ppf_data[0] = &ufunc__beta_ppf_ptr[2*0]
ufunc__beta_ppf_data[1] = &ufunc__beta_ppf_ptr[2*1]
_beta_ppf = np.PyUFunc_FromFuncAndData(ufunc__beta_ppf_loops, ufunc__beta_ppf_data, ufunc__beta_ppf_types, 2, 3, 1, 0, "_beta_ppf", ufunc__beta_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__binom_cdf_loops[2]
cdef void *ufunc__binom_cdf_ptr[4]
cdef void *ufunc__binom_cdf_data[2]
cdef char ufunc__binom_cdf_types[8]
cdef char *ufunc__binom_cdf_doc = (
    "_binom_cdf(x, n, p)\n"
    "\n"
    "Cumulative density function of binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "n : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__binom_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__binom_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__binom_cdf_types[0] = <char>NPY_FLOAT
ufunc__binom_cdf_types[1] = <char>NPY_FLOAT
ufunc__binom_cdf_types[2] = <char>NPY_FLOAT
ufunc__binom_cdf_types[3] = <char>NPY_FLOAT
ufunc__binom_cdf_types[4] = <char>NPY_DOUBLE
ufunc__binom_cdf_types[5] = <char>NPY_DOUBLE
ufunc__binom_cdf_types[6] = <char>NPY_DOUBLE
ufunc__binom_cdf_types[7] = <char>NPY_DOUBLE
ufunc__binom_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom_cdf_float
ufunc__binom_cdf_ptr[2*0+1] = <void*>(<char*>"_binom_cdf")
ufunc__binom_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom_cdf_double
ufunc__binom_cdf_ptr[2*1+1] = <void*>(<char*>"_binom_cdf")
ufunc__binom_cdf_data[0] = &ufunc__binom_cdf_ptr[2*0]
ufunc__binom_cdf_data[1] = &ufunc__binom_cdf_ptr[2*1]
_binom_cdf = np.PyUFunc_FromFuncAndData(ufunc__binom_cdf_loops, ufunc__binom_cdf_data, ufunc__binom_cdf_types, 2, 3, 1, 0, "_binom_cdf", ufunc__binom_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__binom_isf_loops[2]
cdef void *ufunc__binom_isf_ptr[4]
cdef void *ufunc__binom_isf_data[2]
cdef char ufunc__binom_isf_types[8]
cdef char *ufunc__binom_isf_doc = (
    "_binom_isf(x, n, p)\n"
    "\n"
    "Inverse survival function of binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "n : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__binom_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__binom_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__binom_isf_types[0] = <char>NPY_FLOAT
ufunc__binom_isf_types[1] = <char>NPY_FLOAT
ufunc__binom_isf_types[2] = <char>NPY_FLOAT
ufunc__binom_isf_types[3] = <char>NPY_FLOAT
ufunc__binom_isf_types[4] = <char>NPY_DOUBLE
ufunc__binom_isf_types[5] = <char>NPY_DOUBLE
ufunc__binom_isf_types[6] = <char>NPY_DOUBLE
ufunc__binom_isf_types[7] = <char>NPY_DOUBLE
ufunc__binom_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom_isf_float
ufunc__binom_isf_ptr[2*0+1] = <void*>(<char*>"_binom_isf")
ufunc__binom_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom_isf_double
ufunc__binom_isf_ptr[2*1+1] = <void*>(<char*>"_binom_isf")
ufunc__binom_isf_data[0] = &ufunc__binom_isf_ptr[2*0]
ufunc__binom_isf_data[1] = &ufunc__binom_isf_ptr[2*1]
_binom_isf = np.PyUFunc_FromFuncAndData(ufunc__binom_isf_loops, ufunc__binom_isf_data, ufunc__binom_isf_types, 2, 3, 1, 0, "_binom_isf", ufunc__binom_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__binom_pmf_loops[2]
cdef void *ufunc__binom_pmf_ptr[4]
cdef void *ufunc__binom_pmf_data[2]
cdef char ufunc__binom_pmf_types[8]
cdef char *ufunc__binom_pmf_doc = (
    "_binom_pmf(x, n, p)\n"
    "\n"
    "Probability mass function of binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "n : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__binom_pmf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__binom_pmf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__binom_pmf_types[0] = <char>NPY_FLOAT
ufunc__binom_pmf_types[1] = <char>NPY_FLOAT
ufunc__binom_pmf_types[2] = <char>NPY_FLOAT
ufunc__binom_pmf_types[3] = <char>NPY_FLOAT
ufunc__binom_pmf_types[4] = <char>NPY_DOUBLE
ufunc__binom_pmf_types[5] = <char>NPY_DOUBLE
ufunc__binom_pmf_types[6] = <char>NPY_DOUBLE
ufunc__binom_pmf_types[7] = <char>NPY_DOUBLE
ufunc__binom_pmf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom_pmf_float
ufunc__binom_pmf_ptr[2*0+1] = <void*>(<char*>"_binom_pmf")
ufunc__binom_pmf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom_pmf_double
ufunc__binom_pmf_ptr[2*1+1] = <void*>(<char*>"_binom_pmf")
ufunc__binom_pmf_data[0] = &ufunc__binom_pmf_ptr[2*0]
ufunc__binom_pmf_data[1] = &ufunc__binom_pmf_ptr[2*1]
_binom_pmf = np.PyUFunc_FromFuncAndData(ufunc__binom_pmf_loops, ufunc__binom_pmf_data, ufunc__binom_pmf_types, 2, 3, 1, 0, "_binom_pmf", ufunc__binom_pmf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__binom_ppf_loops[2]
cdef void *ufunc__binom_ppf_ptr[4]
cdef void *ufunc__binom_ppf_data[2]
cdef char ufunc__binom_ppf_types[8]
cdef char *ufunc__binom_ppf_doc = (
    "_binom_ppf(x, n, p)\n"
    "\n"
    "Percent point function of binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "n : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__binom_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__binom_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__binom_ppf_types[0] = <char>NPY_FLOAT
ufunc__binom_ppf_types[1] = <char>NPY_FLOAT
ufunc__binom_ppf_types[2] = <char>NPY_FLOAT
ufunc__binom_ppf_types[3] = <char>NPY_FLOAT
ufunc__binom_ppf_types[4] = <char>NPY_DOUBLE
ufunc__binom_ppf_types[5] = <char>NPY_DOUBLE
ufunc__binom_ppf_types[6] = <char>NPY_DOUBLE
ufunc__binom_ppf_types[7] = <char>NPY_DOUBLE
ufunc__binom_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom_ppf_float
ufunc__binom_ppf_ptr[2*0+1] = <void*>(<char*>"_binom_ppf")
ufunc__binom_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom_ppf_double
ufunc__binom_ppf_ptr[2*1+1] = <void*>(<char*>"_binom_ppf")
ufunc__binom_ppf_data[0] = &ufunc__binom_ppf_ptr[2*0]
ufunc__binom_ppf_data[1] = &ufunc__binom_ppf_ptr[2*1]
_binom_ppf = np.PyUFunc_FromFuncAndData(ufunc__binom_ppf_loops, ufunc__binom_ppf_data, ufunc__binom_ppf_types, 2, 3, 1, 0, "_binom_ppf", ufunc__binom_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__binom_sf_loops[2]
cdef void *ufunc__binom_sf_ptr[4]
cdef void *ufunc__binom_sf_data[2]
cdef char ufunc__binom_sf_types[8]
cdef char *ufunc__binom_sf_doc = (
    "_binom_sf(x, n, p)\n"
    "\n"
    "Survival function of binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "n : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__binom_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__binom_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__binom_sf_types[0] = <char>NPY_FLOAT
ufunc__binom_sf_types[1] = <char>NPY_FLOAT
ufunc__binom_sf_types[2] = <char>NPY_FLOAT
ufunc__binom_sf_types[3] = <char>NPY_FLOAT
ufunc__binom_sf_types[4] = <char>NPY_DOUBLE
ufunc__binom_sf_types[5] = <char>NPY_DOUBLE
ufunc__binom_sf_types[6] = <char>NPY_DOUBLE
ufunc__binom_sf_types[7] = <char>NPY_DOUBLE
ufunc__binom_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_binom_sf_float
ufunc__binom_sf_ptr[2*0+1] = <void*>(<char*>"_binom_sf")
ufunc__binom_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_binom_sf_double
ufunc__binom_sf_ptr[2*1+1] = <void*>(<char*>"_binom_sf")
ufunc__binom_sf_data[0] = &ufunc__binom_sf_ptr[2*0]
ufunc__binom_sf_data[1] = &ufunc__binom_sf_ptr[2*1]
_binom_sf = np.PyUFunc_FromFuncAndData(ufunc__binom_sf_loops, ufunc__binom_sf_data, ufunc__binom_sf_types, 2, 3, 1, 0, "_binom_sf", ufunc__binom_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__cosine_cdf_loops[2]
cdef void *ufunc__cosine_cdf_ptr[4]
cdef void *ufunc__cosine_cdf_data[2]
cdef char ufunc__cosine_cdf_types[4]
cdef char *ufunc__cosine_cdf_doc = (
    "_cosine_cdf(x)\n"
    "\n"
    "Cumulative distribution function (CDF) of the cosine distribution::\n"
    "\n"
    "             {             0,              x < -pi\n"
    "    cdf(x) = { (pi + x + sin(x))/(2*pi),   -pi <= x <= pi\n"
    "             {             1,              x > pi\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The cosine distribution CDF evaluated at `x`.")
ufunc__cosine_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__cosine_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__cosine_cdf_types[0] = <char>NPY_FLOAT
ufunc__cosine_cdf_types[1] = <char>NPY_FLOAT
ufunc__cosine_cdf_types[2] = <char>NPY_DOUBLE
ufunc__cosine_cdf_types[3] = <char>NPY_DOUBLE
ufunc__cosine_cdf_ptr[2*0] = <void*>_func_cosine_cdf
ufunc__cosine_cdf_ptr[2*0+1] = <void*>(<char*>"_cosine_cdf")
ufunc__cosine_cdf_ptr[2*1] = <void*>_func_cosine_cdf
ufunc__cosine_cdf_ptr[2*1+1] = <void*>(<char*>"_cosine_cdf")
ufunc__cosine_cdf_data[0] = &ufunc__cosine_cdf_ptr[2*0]
ufunc__cosine_cdf_data[1] = &ufunc__cosine_cdf_ptr[2*1]
_cosine_cdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_cdf_loops, ufunc__cosine_cdf_data, ufunc__cosine_cdf_types, 2, 1, 1, 0, "_cosine_cdf", ufunc__cosine_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__cosine_invcdf_loops[2]
cdef void *ufunc__cosine_invcdf_ptr[4]
cdef void *ufunc__cosine_invcdf_data[2]
cdef char ufunc__cosine_invcdf_types[4]
cdef char *ufunc__cosine_invcdf_doc = (
    "_cosine_invcdf(p)\n"
    "\n"
    "Inverse of the cumulative distribution function (CDF) of the cosine\n"
    "distribution.\n"
    "\n"
    "The CDF of the cosine distribution is::\n"
    "\n"
    "    cdf(x) = (pi + x + sin(x))/(2*pi)\n"
    "\n"
    "This function computes the inverse of cdf(x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    `p` must contain real numbers in the interval ``0 <= p <= 1``.\n"
    "    `nan` is returned for values of `p` outside the interval [0, 1].\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The inverse of the cosine distribution CDF evaluated at `p`.")
ufunc__cosine_invcdf_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__cosine_invcdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__cosine_invcdf_types[0] = <char>NPY_FLOAT
ufunc__cosine_invcdf_types[1] = <char>NPY_FLOAT
ufunc__cosine_invcdf_types[2] = <char>NPY_DOUBLE
ufunc__cosine_invcdf_types[3] = <char>NPY_DOUBLE
ufunc__cosine_invcdf_ptr[2*0] = <void*>_func_cosine_invcdf
ufunc__cosine_invcdf_ptr[2*0+1] = <void*>(<char*>"_cosine_invcdf")
ufunc__cosine_invcdf_ptr[2*1] = <void*>_func_cosine_invcdf
ufunc__cosine_invcdf_ptr[2*1+1] = <void*>(<char*>"_cosine_invcdf")
ufunc__cosine_invcdf_data[0] = &ufunc__cosine_invcdf_ptr[2*0]
ufunc__cosine_invcdf_data[1] = &ufunc__cosine_invcdf_ptr[2*1]
_cosine_invcdf = np.PyUFunc_FromFuncAndData(ufunc__cosine_invcdf_loops, ufunc__cosine_invcdf_data, ufunc__cosine_invcdf_types, 2, 1, 1, 0, "_cosine_invcdf", ufunc__cosine_invcdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ellip_harm_loops[3]
cdef void *ufunc__ellip_harm_ptr[6]
cdef void *ufunc__ellip_harm_data[3]
cdef char ufunc__ellip_harm_types[24]
cdef char *ufunc__ellip_harm_doc = (
    "Internal function, use `ellip_harm` instead.")
ufunc__ellip_harm_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddddddd__As_fffffff_f
ufunc__ellip_harm_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddiiddd__As_ddllddd_d
ufunc__ellip_harm_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddddddd__As_ddddddd_d
ufunc__ellip_harm_types[0] = <char>NPY_FLOAT
ufunc__ellip_harm_types[1] = <char>NPY_FLOAT
ufunc__ellip_harm_types[2] = <char>NPY_FLOAT
ufunc__ellip_harm_types[3] = <char>NPY_FLOAT
ufunc__ellip_harm_types[4] = <char>NPY_FLOAT
ufunc__ellip_harm_types[5] = <char>NPY_FLOAT
ufunc__ellip_harm_types[6] = <char>NPY_FLOAT
ufunc__ellip_harm_types[7] = <char>NPY_FLOAT
ufunc__ellip_harm_types[8] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[9] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[10] = <char>NPY_LONG
ufunc__ellip_harm_types[11] = <char>NPY_LONG
ufunc__ellip_harm_types[12] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[13] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[14] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[15] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[16] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[17] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[18] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[19] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[20] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[21] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[22] = <char>NPY_DOUBLE
ufunc__ellip_harm_types[23] = <char>NPY_DOUBLE
ufunc__ellip_harm_ptr[2*0] = <void*>_func_ellip_harmonic_unsafe
ufunc__ellip_harm_ptr[2*0+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_ptr[2*1] = <void*>_func_ellip_harmonic
ufunc__ellip_harm_ptr[2*1+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_ptr[2*2] = <void*>_func_ellip_harmonic_unsafe
ufunc__ellip_harm_ptr[2*2+1] = <void*>(<char*>"_ellip_harm")
ufunc__ellip_harm_data[0] = &ufunc__ellip_harm_ptr[2*0]
ufunc__ellip_harm_data[1] = &ufunc__ellip_harm_ptr[2*1]
ufunc__ellip_harm_data[2] = &ufunc__ellip_harm_ptr[2*2]
_ellip_harm = np.PyUFunc_FromFuncAndData(ufunc__ellip_harm_loops, ufunc__ellip_harm_data, ufunc__ellip_harm_types, 3, 7, 1, 0, "_ellip_harm", ufunc__ellip_harm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__factorial_loops[2]
cdef void *ufunc__factorial_ptr[4]
cdef void *ufunc__factorial_data[2]
cdef char ufunc__factorial_types[4]
cdef char *ufunc__factorial_doc = (
    "Internal function, do not use.")
ufunc__factorial_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__factorial_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__factorial_types[0] = <char>NPY_FLOAT
ufunc__factorial_types[1] = <char>NPY_FLOAT
ufunc__factorial_types[2] = <char>NPY_DOUBLE
ufunc__factorial_types[3] = <char>NPY_DOUBLE
ufunc__factorial_ptr[2*0] = <void*>_func__factorial
ufunc__factorial_ptr[2*0+1] = <void*>(<char*>"_factorial")
ufunc__factorial_ptr[2*1] = <void*>_func__factorial
ufunc__factorial_ptr[2*1+1] = <void*>(<char*>"_factorial")
ufunc__factorial_data[0] = &ufunc__factorial_ptr[2*0]
ufunc__factorial_data[1] = &ufunc__factorial_ptr[2*1]
_factorial = np.PyUFunc_FromFuncAndData(ufunc__factorial_loops, ufunc__factorial_data, ufunc__factorial_types, 2, 1, 1, 0, "_factorial", ufunc__factorial_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_cdf_loops[2]
cdef void *ufunc__hypergeom_cdf_ptr[4]
cdef void *ufunc__hypergeom_cdf_data[2]
cdef char ufunc__hypergeom_cdf_types[10]
cdef char *ufunc__hypergeom_cdf_doc = (
    "_hypergeom_cdf(x, r, N, M)\n"
    "\n"
    "Cumulative density function of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__hypergeom_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__hypergeom_cdf_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_cdf_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_cdf_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_cdf_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_cdf_types[4] = <char>NPY_FLOAT
ufunc__hypergeom_cdf_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_cdf_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_cdf_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_cdf_types[8] = <char>NPY_DOUBLE
ufunc__hypergeom_cdf_types[9] = <char>NPY_DOUBLE
ufunc__hypergeom_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_cdf_float
ufunc__hypergeom_cdf_ptr[2*0+1] = <void*>(<char*>"_hypergeom_cdf")
ufunc__hypergeom_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_cdf_double
ufunc__hypergeom_cdf_ptr[2*1+1] = <void*>(<char*>"_hypergeom_cdf")
ufunc__hypergeom_cdf_data[0] = &ufunc__hypergeom_cdf_ptr[2*0]
ufunc__hypergeom_cdf_data[1] = &ufunc__hypergeom_cdf_ptr[2*1]
_hypergeom_cdf = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_cdf_loops, ufunc__hypergeom_cdf_data, ufunc__hypergeom_cdf_types, 2, 4, 1, 0, "_hypergeom_cdf", ufunc__hypergeom_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_mean_loops[2]
cdef void *ufunc__hypergeom_mean_ptr[4]
cdef void *ufunc__hypergeom_mean_data[2]
cdef char ufunc__hypergeom_mean_types[8]
cdef char *ufunc__hypergeom_mean_doc = (
    "_hypergeom_mean(r, N, M)\n"
    "\n"
    "Mean of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_mean_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__hypergeom_mean_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__hypergeom_mean_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_mean_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_mean_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_mean_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_mean_types[4] = <char>NPY_DOUBLE
ufunc__hypergeom_mean_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_mean_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_mean_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_mean_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_mean_float
ufunc__hypergeom_mean_ptr[2*0+1] = <void*>(<char*>"_hypergeom_mean")
ufunc__hypergeom_mean_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_mean_double
ufunc__hypergeom_mean_ptr[2*1+1] = <void*>(<char*>"_hypergeom_mean")
ufunc__hypergeom_mean_data[0] = &ufunc__hypergeom_mean_ptr[2*0]
ufunc__hypergeom_mean_data[1] = &ufunc__hypergeom_mean_ptr[2*1]
_hypergeom_mean = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_mean_loops, ufunc__hypergeom_mean_data, ufunc__hypergeom_mean_types, 2, 3, 1, 0, "_hypergeom_mean", ufunc__hypergeom_mean_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_pmf_loops[2]
cdef void *ufunc__hypergeom_pmf_ptr[4]
cdef void *ufunc__hypergeom_pmf_data[2]
cdef char ufunc__hypergeom_pmf_types[10]
cdef char *ufunc__hypergeom_pmf_doc = (
    "_hypergeom_pmf(x, r, N, M)\n"
    "\n"
    "Probability mass function of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_pmf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__hypergeom_pmf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__hypergeom_pmf_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_pmf_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_pmf_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_pmf_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_pmf_types[4] = <char>NPY_FLOAT
ufunc__hypergeom_pmf_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_pmf_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_pmf_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_pmf_types[8] = <char>NPY_DOUBLE
ufunc__hypergeom_pmf_types[9] = <char>NPY_DOUBLE
ufunc__hypergeom_pmf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_pmf_float
ufunc__hypergeom_pmf_ptr[2*0+1] = <void*>(<char*>"_hypergeom_pmf")
ufunc__hypergeom_pmf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_pmf_double
ufunc__hypergeom_pmf_ptr[2*1+1] = <void*>(<char*>"_hypergeom_pmf")
ufunc__hypergeom_pmf_data[0] = &ufunc__hypergeom_pmf_ptr[2*0]
ufunc__hypergeom_pmf_data[1] = &ufunc__hypergeom_pmf_ptr[2*1]
_hypergeom_pmf = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_pmf_loops, ufunc__hypergeom_pmf_data, ufunc__hypergeom_pmf_types, 2, 4, 1, 0, "_hypergeom_pmf", ufunc__hypergeom_pmf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_sf_loops[2]
cdef void *ufunc__hypergeom_sf_ptr[4]
cdef void *ufunc__hypergeom_sf_data[2]
cdef char ufunc__hypergeom_sf_types[10]
cdef char *ufunc__hypergeom_sf_doc = (
    "_hypergeom_sf(x, r, N, M)\n"
    "\n"
    "Survival function of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__hypergeom_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__hypergeom_sf_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_sf_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_sf_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_sf_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_sf_types[4] = <char>NPY_FLOAT
ufunc__hypergeom_sf_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_sf_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_sf_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_sf_types[8] = <char>NPY_DOUBLE
ufunc__hypergeom_sf_types[9] = <char>NPY_DOUBLE
ufunc__hypergeom_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_sf_float
ufunc__hypergeom_sf_ptr[2*0+1] = <void*>(<char*>"_hypergeom_sf")
ufunc__hypergeom_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_sf_double
ufunc__hypergeom_sf_ptr[2*1+1] = <void*>(<char*>"_hypergeom_sf")
ufunc__hypergeom_sf_data[0] = &ufunc__hypergeom_sf_ptr[2*0]
ufunc__hypergeom_sf_data[1] = &ufunc__hypergeom_sf_ptr[2*1]
_hypergeom_sf = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_sf_loops, ufunc__hypergeom_sf_data, ufunc__hypergeom_sf_types, 2, 4, 1, 0, "_hypergeom_sf", ufunc__hypergeom_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_skewness_loops[2]
cdef void *ufunc__hypergeom_skewness_ptr[4]
cdef void *ufunc__hypergeom_skewness_data[2]
cdef char ufunc__hypergeom_skewness_types[8]
cdef char *ufunc__hypergeom_skewness_doc = (
    "_hypergeom_skewness(r, N, M)\n"
    "\n"
    "Skewness of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_skewness_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__hypergeom_skewness_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__hypergeom_skewness_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_skewness_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_skewness_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_skewness_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_skewness_types[4] = <char>NPY_DOUBLE
ufunc__hypergeom_skewness_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_skewness_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_skewness_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_skewness_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_skewness_float
ufunc__hypergeom_skewness_ptr[2*0+1] = <void*>(<char*>"_hypergeom_skewness")
ufunc__hypergeom_skewness_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_skewness_double
ufunc__hypergeom_skewness_ptr[2*1+1] = <void*>(<char*>"_hypergeom_skewness")
ufunc__hypergeom_skewness_data[0] = &ufunc__hypergeom_skewness_ptr[2*0]
ufunc__hypergeom_skewness_data[1] = &ufunc__hypergeom_skewness_ptr[2*1]
_hypergeom_skewness = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_skewness_loops, ufunc__hypergeom_skewness_data, ufunc__hypergeom_skewness_types, 2, 3, 1, 0, "_hypergeom_skewness", ufunc__hypergeom_skewness_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__hypergeom_variance_loops[2]
cdef void *ufunc__hypergeom_variance_ptr[4]
cdef void *ufunc__hypergeom_variance_data[2]
cdef char ufunc__hypergeom_variance_types[8]
cdef char *ufunc__hypergeom_variance_doc = (
    "_hypergeom_variance(r, N, M)\n"
    "\n"
    "Mean of hypergeometric distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r, N, M : array_like\n"
    "    Positive, integer-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__hypergeom_variance_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__hypergeom_variance_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__hypergeom_variance_types[0] = <char>NPY_FLOAT
ufunc__hypergeom_variance_types[1] = <char>NPY_FLOAT
ufunc__hypergeom_variance_types[2] = <char>NPY_FLOAT
ufunc__hypergeom_variance_types[3] = <char>NPY_FLOAT
ufunc__hypergeom_variance_types[4] = <char>NPY_DOUBLE
ufunc__hypergeom_variance_types[5] = <char>NPY_DOUBLE
ufunc__hypergeom_variance_types[6] = <char>NPY_DOUBLE
ufunc__hypergeom_variance_types[7] = <char>NPY_DOUBLE
ufunc__hypergeom_variance_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_variance_float
ufunc__hypergeom_variance_ptr[2*0+1] = <void*>(<char*>"_hypergeom_variance")
ufunc__hypergeom_variance_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_hypergeom_variance_double
ufunc__hypergeom_variance_ptr[2*1+1] = <void*>(<char*>"_hypergeom_variance")
ufunc__hypergeom_variance_data[0] = &ufunc__hypergeom_variance_ptr[2*0]
ufunc__hypergeom_variance_data[1] = &ufunc__hypergeom_variance_ptr[2*1]
_hypergeom_variance = np.PyUFunc_FromFuncAndData(ufunc__hypergeom_variance_loops, ufunc__hypergeom_variance_data, ufunc__hypergeom_variance_types, 2, 3, 1, 0, "_hypergeom_variance", ufunc__hypergeom_variance_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__igam_fac_loops[2]
cdef void *ufunc__igam_fac_ptr[4]
cdef void *ufunc__igam_fac_data[2]
cdef char ufunc__igam_fac_types[6]
cdef char *ufunc__igam_fac_doc = (
    "Internal function, do not use.")
ufunc__igam_fac_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__igam_fac_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__igam_fac_types[0] = <char>NPY_FLOAT
ufunc__igam_fac_types[1] = <char>NPY_FLOAT
ufunc__igam_fac_types[2] = <char>NPY_FLOAT
ufunc__igam_fac_types[3] = <char>NPY_DOUBLE
ufunc__igam_fac_types[4] = <char>NPY_DOUBLE
ufunc__igam_fac_types[5] = <char>NPY_DOUBLE
ufunc__igam_fac_ptr[2*0] = <void*>_func_cephes_igam_fac
ufunc__igam_fac_ptr[2*0+1] = <void*>(<char*>"_igam_fac")
ufunc__igam_fac_ptr[2*1] = <void*>_func_cephes_igam_fac
ufunc__igam_fac_ptr[2*1+1] = <void*>(<char*>"_igam_fac")
ufunc__igam_fac_data[0] = &ufunc__igam_fac_ptr[2*0]
ufunc__igam_fac_data[1] = &ufunc__igam_fac_ptr[2*1]
_igam_fac = np.PyUFunc_FromFuncAndData(ufunc__igam_fac_loops, ufunc__igam_fac_data, ufunc__igam_fac_types, 2, 2, 1, 0, "_igam_fac", ufunc__igam_fac_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__invgauss_isf_loops[2]
cdef void *ufunc__invgauss_isf_ptr[4]
cdef void *ufunc__invgauss_isf_data[2]
cdef char ufunc__invgauss_isf_types[8]
cdef char *ufunc__invgauss_isf_doc = (
    "_invgauss_isf(x, mu, s)\n"
    "\n"
    "Inverse survival function of inverse gaussian distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "mu : array_like\n"
    "    Positive, real-valued parameters\n"
    "s : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__invgauss_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__invgauss_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__invgauss_isf_types[0] = <char>NPY_FLOAT
ufunc__invgauss_isf_types[1] = <char>NPY_FLOAT
ufunc__invgauss_isf_types[2] = <char>NPY_FLOAT
ufunc__invgauss_isf_types[3] = <char>NPY_FLOAT
ufunc__invgauss_isf_types[4] = <char>NPY_DOUBLE
ufunc__invgauss_isf_types[5] = <char>NPY_DOUBLE
ufunc__invgauss_isf_types[6] = <char>NPY_DOUBLE
ufunc__invgauss_isf_types[7] = <char>NPY_DOUBLE
ufunc__invgauss_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_invgauss_isf_float
ufunc__invgauss_isf_ptr[2*0+1] = <void*>(<char*>"_invgauss_isf")
ufunc__invgauss_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_invgauss_isf_double
ufunc__invgauss_isf_ptr[2*1+1] = <void*>(<char*>"_invgauss_isf")
ufunc__invgauss_isf_data[0] = &ufunc__invgauss_isf_ptr[2*0]
ufunc__invgauss_isf_data[1] = &ufunc__invgauss_isf_ptr[2*1]
_invgauss_isf = np.PyUFunc_FromFuncAndData(ufunc__invgauss_isf_loops, ufunc__invgauss_isf_data, ufunc__invgauss_isf_types, 2, 3, 1, 0, "_invgauss_isf", ufunc__invgauss_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__invgauss_ppf_loops[2]
cdef void *ufunc__invgauss_ppf_ptr[4]
cdef void *ufunc__invgauss_ppf_data[2]
cdef char ufunc__invgauss_ppf_types[8]
cdef char *ufunc__invgauss_ppf_doc = (
    "_invgauss_ppf(x, mu)\n"
    "\n"
    "Percent point function of inverse gaussian distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "mu : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__invgauss_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__invgauss_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__invgauss_ppf_types[0] = <char>NPY_FLOAT
ufunc__invgauss_ppf_types[1] = <char>NPY_FLOAT
ufunc__invgauss_ppf_types[2] = <char>NPY_FLOAT
ufunc__invgauss_ppf_types[3] = <char>NPY_FLOAT
ufunc__invgauss_ppf_types[4] = <char>NPY_DOUBLE
ufunc__invgauss_ppf_types[5] = <char>NPY_DOUBLE
ufunc__invgauss_ppf_types[6] = <char>NPY_DOUBLE
ufunc__invgauss_ppf_types[7] = <char>NPY_DOUBLE
ufunc__invgauss_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_invgauss_ppf_float
ufunc__invgauss_ppf_ptr[2*0+1] = <void*>(<char*>"_invgauss_ppf")
ufunc__invgauss_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_invgauss_ppf_double
ufunc__invgauss_ppf_ptr[2*1+1] = <void*>(<char*>"_invgauss_ppf")
ufunc__invgauss_ppf_data[0] = &ufunc__invgauss_ppf_ptr[2*0]
ufunc__invgauss_ppf_data[1] = &ufunc__invgauss_ppf_ptr[2*1]
_invgauss_ppf = np.PyUFunc_FromFuncAndData(ufunc__invgauss_ppf_loops, ufunc__invgauss_ppf_data, ufunc__invgauss_ppf_types, 2, 3, 1, 0, "_invgauss_ppf", ufunc__invgauss_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogc_loops[2]
cdef void *ufunc__kolmogc_ptr[4]
cdef void *ufunc__kolmogc_data[2]
cdef char ufunc__kolmogc_types[4]
cdef char *ufunc__kolmogc_doc = (
    "Internal function, do not use.")
ufunc__kolmogc_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogc_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogc_types[0] = <char>NPY_FLOAT
ufunc__kolmogc_types[1] = <char>NPY_FLOAT
ufunc__kolmogc_types[2] = <char>NPY_DOUBLE
ufunc__kolmogc_types[3] = <char>NPY_DOUBLE
ufunc__kolmogc_ptr[2*0] = <void*>_func_cephes_kolmogc
ufunc__kolmogc_ptr[2*0+1] = <void*>(<char*>"_kolmogc")
ufunc__kolmogc_ptr[2*1] = <void*>_func_cephes_kolmogc
ufunc__kolmogc_ptr[2*1+1] = <void*>(<char*>"_kolmogc")
ufunc__kolmogc_data[0] = &ufunc__kolmogc_ptr[2*0]
ufunc__kolmogc_data[1] = &ufunc__kolmogc_ptr[2*1]
_kolmogc = np.PyUFunc_FromFuncAndData(ufunc__kolmogc_loops, ufunc__kolmogc_data, ufunc__kolmogc_types, 2, 1, 1, 0, "_kolmogc", ufunc__kolmogc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogci_loops[2]
cdef void *ufunc__kolmogci_ptr[4]
cdef void *ufunc__kolmogci_data[2]
cdef char ufunc__kolmogci_types[4]
cdef char *ufunc__kolmogci_doc = (
    "Internal function, do not use.")
ufunc__kolmogci_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogci_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogci_types[0] = <char>NPY_FLOAT
ufunc__kolmogci_types[1] = <char>NPY_FLOAT
ufunc__kolmogci_types[2] = <char>NPY_DOUBLE
ufunc__kolmogci_types[3] = <char>NPY_DOUBLE
ufunc__kolmogci_ptr[2*0] = <void*>_func_cephes_kolmogci
ufunc__kolmogci_ptr[2*0+1] = <void*>(<char*>"_kolmogci")
ufunc__kolmogci_ptr[2*1] = <void*>_func_cephes_kolmogci
ufunc__kolmogci_ptr[2*1+1] = <void*>(<char*>"_kolmogci")
ufunc__kolmogci_data[0] = &ufunc__kolmogci_ptr[2*0]
ufunc__kolmogci_data[1] = &ufunc__kolmogci_ptr[2*1]
_kolmogci = np.PyUFunc_FromFuncAndData(ufunc__kolmogci_loops, ufunc__kolmogci_data, ufunc__kolmogci_types, 2, 1, 1, 0, "_kolmogci", ufunc__kolmogci_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__kolmogp_loops[2]
cdef void *ufunc__kolmogp_ptr[4]
cdef void *ufunc__kolmogp_data[2]
cdef char ufunc__kolmogp_types[4]
cdef char *ufunc__kolmogp_doc = (
    "Internal function, do not use.")
ufunc__kolmogp_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__kolmogp_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__kolmogp_types[0] = <char>NPY_FLOAT
ufunc__kolmogp_types[1] = <char>NPY_FLOAT
ufunc__kolmogp_types[2] = <char>NPY_DOUBLE
ufunc__kolmogp_types[3] = <char>NPY_DOUBLE
ufunc__kolmogp_ptr[2*0] = <void*>_func_cephes_kolmogp
ufunc__kolmogp_ptr[2*0+1] = <void*>(<char*>"_kolmogp")
ufunc__kolmogp_ptr[2*1] = <void*>_func_cephes_kolmogp
ufunc__kolmogp_ptr[2*1+1] = <void*>(<char*>"_kolmogp")
ufunc__kolmogp_data[0] = &ufunc__kolmogp_ptr[2*0]
ufunc__kolmogp_data[1] = &ufunc__kolmogp_ptr[2*1]
_kolmogp = np.PyUFunc_FromFuncAndData(ufunc__kolmogp_loops, ufunc__kolmogp_data, ufunc__kolmogp_types, 2, 1, 1, 0, "_kolmogp", ufunc__kolmogp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lanczos_sum_expg_scaled_loops[2]
cdef void *ufunc__lanczos_sum_expg_scaled_ptr[4]
cdef void *ufunc__lanczos_sum_expg_scaled_data[2]
cdef char ufunc__lanczos_sum_expg_scaled_types[4]
cdef char *ufunc__lanczos_sum_expg_scaled_doc = (
    "Internal function, do not use.")
ufunc__lanczos_sum_expg_scaled_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__lanczos_sum_expg_scaled_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__lanczos_sum_expg_scaled_types[0] = <char>NPY_FLOAT
ufunc__lanczos_sum_expg_scaled_types[1] = <char>NPY_FLOAT
ufunc__lanczos_sum_expg_scaled_types[2] = <char>NPY_DOUBLE
ufunc__lanczos_sum_expg_scaled_types[3] = <char>NPY_DOUBLE
ufunc__lanczos_sum_expg_scaled_ptr[2*0] = <void*>_func_cephes_lanczos_sum_expg_scaled
ufunc__lanczos_sum_expg_scaled_ptr[2*0+1] = <void*>(<char*>"_lanczos_sum_expg_scaled")
ufunc__lanczos_sum_expg_scaled_ptr[2*1] = <void*>_func_cephes_lanczos_sum_expg_scaled
ufunc__lanczos_sum_expg_scaled_ptr[2*1+1] = <void*>(<char*>"_lanczos_sum_expg_scaled")
ufunc__lanczos_sum_expg_scaled_data[0] = &ufunc__lanczos_sum_expg_scaled_ptr[2*0]
ufunc__lanczos_sum_expg_scaled_data[1] = &ufunc__lanczos_sum_expg_scaled_ptr[2*1]
_lanczos_sum_expg_scaled = np.PyUFunc_FromFuncAndData(ufunc__lanczos_sum_expg_scaled_loops, ufunc__lanczos_sum_expg_scaled_data, ufunc__lanczos_sum_expg_scaled_types, 2, 1, 1, 0, "_lanczos_sum_expg_scaled", ufunc__lanczos_sum_expg_scaled_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__lgam1p_loops[2]
cdef void *ufunc__lgam1p_ptr[4]
cdef void *ufunc__lgam1p_data[2]
cdef char ufunc__lgam1p_types[4]
cdef char *ufunc__lgam1p_doc = (
    "Internal function, do not use.")
ufunc__lgam1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__lgam1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__lgam1p_types[0] = <char>NPY_FLOAT
ufunc__lgam1p_types[1] = <char>NPY_FLOAT
ufunc__lgam1p_types[2] = <char>NPY_DOUBLE
ufunc__lgam1p_types[3] = <char>NPY_DOUBLE
ufunc__lgam1p_ptr[2*0] = <void*>_func_cephes_lgam1p
ufunc__lgam1p_ptr[2*0+1] = <void*>(<char*>"_lgam1p")
ufunc__lgam1p_ptr[2*1] = <void*>_func_cephes_lgam1p
ufunc__lgam1p_ptr[2*1+1] = <void*>(<char*>"_lgam1p")
ufunc__lgam1p_data[0] = &ufunc__lgam1p_ptr[2*0]
ufunc__lgam1p_data[1] = &ufunc__lgam1p_ptr[2*1]
_lgam1p = np.PyUFunc_FromFuncAndData(ufunc__lgam1p_loops, ufunc__lgam1p_data, ufunc__lgam1p_types, 2, 1, 1, 0, "_lgam1p", ufunc__lgam1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__log1pmx_loops[2]
cdef void *ufunc__log1pmx_ptr[4]
cdef void *ufunc__log1pmx_data[2]
cdef char ufunc__log1pmx_types[4]
cdef char *ufunc__log1pmx_doc = (
    "Internal function, do not use.")
ufunc__log1pmx_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__log1pmx_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__log1pmx_types[0] = <char>NPY_FLOAT
ufunc__log1pmx_types[1] = <char>NPY_FLOAT
ufunc__log1pmx_types[2] = <char>NPY_DOUBLE
ufunc__log1pmx_types[3] = <char>NPY_DOUBLE
ufunc__log1pmx_ptr[2*0] = <void*>_func_cephes_log1pmx
ufunc__log1pmx_ptr[2*0+1] = <void*>(<char*>"_log1pmx")
ufunc__log1pmx_ptr[2*1] = <void*>_func_cephes_log1pmx
ufunc__log1pmx_ptr[2*1+1] = <void*>(<char*>"_log1pmx")
ufunc__log1pmx_data[0] = &ufunc__log1pmx_ptr[2*0]
ufunc__log1pmx_data[1] = &ufunc__log1pmx_ptr[2*1]
_log1pmx = np.PyUFunc_FromFuncAndData(ufunc__log1pmx_loops, ufunc__log1pmx_data, ufunc__log1pmx_types, 2, 1, 1, 0, "_log1pmx", ufunc__log1pmx_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_cdf_loops[2]
cdef void *ufunc__nbinom_cdf_ptr[4]
cdef void *ufunc__nbinom_cdf_data[2]
cdef char ufunc__nbinom_cdf_types[8]
cdef char *ufunc__nbinom_cdf_doc = (
    "_nbinom_cdf(x, r, p)\n"
    "\n"
    "Cumulative density function of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nbinom_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nbinom_cdf_types[0] = <char>NPY_FLOAT
ufunc__nbinom_cdf_types[1] = <char>NPY_FLOAT
ufunc__nbinom_cdf_types[2] = <char>NPY_FLOAT
ufunc__nbinom_cdf_types[3] = <char>NPY_FLOAT
ufunc__nbinom_cdf_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_cdf_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_cdf_types[6] = <char>NPY_DOUBLE
ufunc__nbinom_cdf_types[7] = <char>NPY_DOUBLE
ufunc__nbinom_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_cdf_float
ufunc__nbinom_cdf_ptr[2*0+1] = <void*>(<char*>"_nbinom_cdf")
ufunc__nbinom_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_cdf_double
ufunc__nbinom_cdf_ptr[2*1+1] = <void*>(<char*>"_nbinom_cdf")
ufunc__nbinom_cdf_data[0] = &ufunc__nbinom_cdf_ptr[2*0]
ufunc__nbinom_cdf_data[1] = &ufunc__nbinom_cdf_ptr[2*1]
_nbinom_cdf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_cdf_loops, ufunc__nbinom_cdf_data, ufunc__nbinom_cdf_types, 2, 3, 1, 0, "_nbinom_cdf", ufunc__nbinom_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_isf_loops[2]
cdef void *ufunc__nbinom_isf_ptr[4]
cdef void *ufunc__nbinom_isf_data[2]
cdef char ufunc__nbinom_isf_types[8]
cdef char *ufunc__nbinom_isf_doc = (
    "_nbinom_isf(x, r, p)\n"
    "\n"
    "Inverse survival function of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nbinom_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nbinom_isf_types[0] = <char>NPY_FLOAT
ufunc__nbinom_isf_types[1] = <char>NPY_FLOAT
ufunc__nbinom_isf_types[2] = <char>NPY_FLOAT
ufunc__nbinom_isf_types[3] = <char>NPY_FLOAT
ufunc__nbinom_isf_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_isf_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_isf_types[6] = <char>NPY_DOUBLE
ufunc__nbinom_isf_types[7] = <char>NPY_DOUBLE
ufunc__nbinom_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_isf_float
ufunc__nbinom_isf_ptr[2*0+1] = <void*>(<char*>"_nbinom_isf")
ufunc__nbinom_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_isf_double
ufunc__nbinom_isf_ptr[2*1+1] = <void*>(<char*>"_nbinom_isf")
ufunc__nbinom_isf_data[0] = &ufunc__nbinom_isf_ptr[2*0]
ufunc__nbinom_isf_data[1] = &ufunc__nbinom_isf_ptr[2*1]
_nbinom_isf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_isf_loops, ufunc__nbinom_isf_data, ufunc__nbinom_isf_types, 2, 3, 1, 0, "_nbinom_isf", ufunc__nbinom_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_kurtosis_excess_loops[2]
cdef void *ufunc__nbinom_kurtosis_excess_ptr[4]
cdef void *ufunc__nbinom_kurtosis_excess_data[2]
cdef char ufunc__nbinom_kurtosis_excess_types[6]
cdef char *ufunc__nbinom_kurtosis_excess_doc = (
    "_nbinom_kurtosis_excess(r, p)\n"
    "\n"
    "Kurtosis excess of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_kurtosis_excess_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nbinom_kurtosis_excess_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nbinom_kurtosis_excess_types[0] = <char>NPY_FLOAT
ufunc__nbinom_kurtosis_excess_types[1] = <char>NPY_FLOAT
ufunc__nbinom_kurtosis_excess_types[2] = <char>NPY_FLOAT
ufunc__nbinom_kurtosis_excess_types[3] = <char>NPY_DOUBLE
ufunc__nbinom_kurtosis_excess_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_kurtosis_excess_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_kurtosis_excess_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_kurtosis_excess_float
ufunc__nbinom_kurtosis_excess_ptr[2*0+1] = <void*>(<char*>"_nbinom_kurtosis_excess")
ufunc__nbinom_kurtosis_excess_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_kurtosis_excess_double
ufunc__nbinom_kurtosis_excess_ptr[2*1+1] = <void*>(<char*>"_nbinom_kurtosis_excess")
ufunc__nbinom_kurtosis_excess_data[0] = &ufunc__nbinom_kurtosis_excess_ptr[2*0]
ufunc__nbinom_kurtosis_excess_data[1] = &ufunc__nbinom_kurtosis_excess_ptr[2*1]
_nbinom_kurtosis_excess = np.PyUFunc_FromFuncAndData(ufunc__nbinom_kurtosis_excess_loops, ufunc__nbinom_kurtosis_excess_data, ufunc__nbinom_kurtosis_excess_types, 2, 2, 1, 0, "_nbinom_kurtosis_excess", ufunc__nbinom_kurtosis_excess_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_mean_loops[2]
cdef void *ufunc__nbinom_mean_ptr[4]
cdef void *ufunc__nbinom_mean_data[2]
cdef char ufunc__nbinom_mean_types[6]
cdef char *ufunc__nbinom_mean_doc = (
    "_nbinom_mean(r, p)\n"
    "\n"
    "Mean of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_mean_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nbinom_mean_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nbinom_mean_types[0] = <char>NPY_FLOAT
ufunc__nbinom_mean_types[1] = <char>NPY_FLOAT
ufunc__nbinom_mean_types[2] = <char>NPY_FLOAT
ufunc__nbinom_mean_types[3] = <char>NPY_DOUBLE
ufunc__nbinom_mean_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_mean_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_mean_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_mean_float
ufunc__nbinom_mean_ptr[2*0+1] = <void*>(<char*>"_nbinom_mean")
ufunc__nbinom_mean_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_mean_double
ufunc__nbinom_mean_ptr[2*1+1] = <void*>(<char*>"_nbinom_mean")
ufunc__nbinom_mean_data[0] = &ufunc__nbinom_mean_ptr[2*0]
ufunc__nbinom_mean_data[1] = &ufunc__nbinom_mean_ptr[2*1]
_nbinom_mean = np.PyUFunc_FromFuncAndData(ufunc__nbinom_mean_loops, ufunc__nbinom_mean_data, ufunc__nbinom_mean_types, 2, 2, 1, 0, "_nbinom_mean", ufunc__nbinom_mean_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_pmf_loops[2]
cdef void *ufunc__nbinom_pmf_ptr[4]
cdef void *ufunc__nbinom_pmf_data[2]
cdef char ufunc__nbinom_pmf_types[8]
cdef char *ufunc__nbinom_pmf_doc = (
    "_nbinom_pmf(x, r, p)\n"
    "\n"
    "Probability mass function of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_pmf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nbinom_pmf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nbinom_pmf_types[0] = <char>NPY_FLOAT
ufunc__nbinom_pmf_types[1] = <char>NPY_FLOAT
ufunc__nbinom_pmf_types[2] = <char>NPY_FLOAT
ufunc__nbinom_pmf_types[3] = <char>NPY_FLOAT
ufunc__nbinom_pmf_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_pmf_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_pmf_types[6] = <char>NPY_DOUBLE
ufunc__nbinom_pmf_types[7] = <char>NPY_DOUBLE
ufunc__nbinom_pmf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_pmf_float
ufunc__nbinom_pmf_ptr[2*0+1] = <void*>(<char*>"_nbinom_pmf")
ufunc__nbinom_pmf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_pmf_double
ufunc__nbinom_pmf_ptr[2*1+1] = <void*>(<char*>"_nbinom_pmf")
ufunc__nbinom_pmf_data[0] = &ufunc__nbinom_pmf_ptr[2*0]
ufunc__nbinom_pmf_data[1] = &ufunc__nbinom_pmf_ptr[2*1]
_nbinom_pmf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_pmf_loops, ufunc__nbinom_pmf_data, ufunc__nbinom_pmf_types, 2, 3, 1, 0, "_nbinom_pmf", ufunc__nbinom_pmf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_ppf_loops[2]
cdef void *ufunc__nbinom_ppf_ptr[4]
cdef void *ufunc__nbinom_ppf_data[2]
cdef char ufunc__nbinom_ppf_types[8]
cdef char *ufunc__nbinom_ppf_doc = (
    "_nbinom_ppf(x, r, p)\n"
    "\n"
    "Percent point function of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nbinom_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nbinom_ppf_types[0] = <char>NPY_FLOAT
ufunc__nbinom_ppf_types[1] = <char>NPY_FLOAT
ufunc__nbinom_ppf_types[2] = <char>NPY_FLOAT
ufunc__nbinom_ppf_types[3] = <char>NPY_FLOAT
ufunc__nbinom_ppf_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_ppf_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_ppf_types[6] = <char>NPY_DOUBLE
ufunc__nbinom_ppf_types[7] = <char>NPY_DOUBLE
ufunc__nbinom_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_ppf_float
ufunc__nbinom_ppf_ptr[2*0+1] = <void*>(<char*>"_nbinom_ppf")
ufunc__nbinom_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_ppf_double
ufunc__nbinom_ppf_ptr[2*1+1] = <void*>(<char*>"_nbinom_ppf")
ufunc__nbinom_ppf_data[0] = &ufunc__nbinom_ppf_ptr[2*0]
ufunc__nbinom_ppf_data[1] = &ufunc__nbinom_ppf_ptr[2*1]
_nbinom_ppf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_ppf_loops, ufunc__nbinom_ppf_data, ufunc__nbinom_ppf_types, 2, 3, 1, 0, "_nbinom_ppf", ufunc__nbinom_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_sf_loops[2]
cdef void *ufunc__nbinom_sf_ptr[4]
cdef void *ufunc__nbinom_sf_data[2]
cdef char ufunc__nbinom_sf_types[8]
cdef char *ufunc__nbinom_sf_doc = (
    "_nbinom_sf(x, r, p)\n"
    "\n"
    "Survival function of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nbinom_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nbinom_sf_types[0] = <char>NPY_FLOAT
ufunc__nbinom_sf_types[1] = <char>NPY_FLOAT
ufunc__nbinom_sf_types[2] = <char>NPY_FLOAT
ufunc__nbinom_sf_types[3] = <char>NPY_FLOAT
ufunc__nbinom_sf_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_sf_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_sf_types[6] = <char>NPY_DOUBLE
ufunc__nbinom_sf_types[7] = <char>NPY_DOUBLE
ufunc__nbinom_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_sf_float
ufunc__nbinom_sf_ptr[2*0+1] = <void*>(<char*>"_nbinom_sf")
ufunc__nbinom_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_sf_double
ufunc__nbinom_sf_ptr[2*1+1] = <void*>(<char*>"_nbinom_sf")
ufunc__nbinom_sf_data[0] = &ufunc__nbinom_sf_ptr[2*0]
ufunc__nbinom_sf_data[1] = &ufunc__nbinom_sf_ptr[2*1]
_nbinom_sf = np.PyUFunc_FromFuncAndData(ufunc__nbinom_sf_loops, ufunc__nbinom_sf_data, ufunc__nbinom_sf_types, 2, 3, 1, 0, "_nbinom_sf", ufunc__nbinom_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_skewness_loops[2]
cdef void *ufunc__nbinom_skewness_ptr[4]
cdef void *ufunc__nbinom_skewness_data[2]
cdef char ufunc__nbinom_skewness_types[6]
cdef char *ufunc__nbinom_skewness_doc = (
    "_nbinom_skewness(r, p)\n"
    "\n"
    "Skewness of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_skewness_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nbinom_skewness_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nbinom_skewness_types[0] = <char>NPY_FLOAT
ufunc__nbinom_skewness_types[1] = <char>NPY_FLOAT
ufunc__nbinom_skewness_types[2] = <char>NPY_FLOAT
ufunc__nbinom_skewness_types[3] = <char>NPY_DOUBLE
ufunc__nbinom_skewness_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_skewness_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_skewness_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_skewness_float
ufunc__nbinom_skewness_ptr[2*0+1] = <void*>(<char*>"_nbinom_skewness")
ufunc__nbinom_skewness_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_skewness_double
ufunc__nbinom_skewness_ptr[2*1+1] = <void*>(<char*>"_nbinom_skewness")
ufunc__nbinom_skewness_data[0] = &ufunc__nbinom_skewness_ptr[2*0]
ufunc__nbinom_skewness_data[1] = &ufunc__nbinom_skewness_ptr[2*1]
_nbinom_skewness = np.PyUFunc_FromFuncAndData(ufunc__nbinom_skewness_loops, ufunc__nbinom_skewness_data, ufunc__nbinom_skewness_types, 2, 2, 1, 0, "_nbinom_skewness", ufunc__nbinom_skewness_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nbinom_variance_loops[2]
cdef void *ufunc__nbinom_variance_ptr[4]
cdef void *ufunc__nbinom_variance_data[2]
cdef char ufunc__nbinom_variance_types[6]
cdef char *ufunc__nbinom_variance_doc = (
    "_nbinom_variance(r, p)\n"
    "\n"
    "Variance of negative binomial distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "r : array_like\n"
    "    Positive, integer-valued parameter\n"
    "p : array_like\n"
    "    Positive, real-valued parameter\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nbinom_variance_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nbinom_variance_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nbinom_variance_types[0] = <char>NPY_FLOAT
ufunc__nbinom_variance_types[1] = <char>NPY_FLOAT
ufunc__nbinom_variance_types[2] = <char>NPY_FLOAT
ufunc__nbinom_variance_types[3] = <char>NPY_DOUBLE
ufunc__nbinom_variance_types[4] = <char>NPY_DOUBLE
ufunc__nbinom_variance_types[5] = <char>NPY_DOUBLE
ufunc__nbinom_variance_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nbinom_variance_float
ufunc__nbinom_variance_ptr[2*0+1] = <void*>(<char*>"_nbinom_variance")
ufunc__nbinom_variance_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nbinom_variance_double
ufunc__nbinom_variance_ptr[2*1+1] = <void*>(<char*>"_nbinom_variance")
ufunc__nbinom_variance_data[0] = &ufunc__nbinom_variance_ptr[2*0]
ufunc__nbinom_variance_data[1] = &ufunc__nbinom_variance_ptr[2*1]
_nbinom_variance = np.PyUFunc_FromFuncAndData(ufunc__nbinom_variance_loops, ufunc__nbinom_variance_data, ufunc__nbinom_variance_types, 2, 2, 1, 0, "_nbinom_variance", ufunc__nbinom_variance_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_cdf_loops[2]
cdef void *ufunc__ncf_cdf_ptr[4]
cdef void *ufunc__ncf_cdf_data[2]
cdef char ufunc__ncf_cdf_types[10]
cdef char *ufunc__ncf_cdf_doc = (
    "_ncf_cdf(x, v1, v2, l)\n"
    "\n"
    "Cumulative density function of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__ncf_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__ncf_cdf_types[0] = <char>NPY_FLOAT
ufunc__ncf_cdf_types[1] = <char>NPY_FLOAT
ufunc__ncf_cdf_types[2] = <char>NPY_FLOAT
ufunc__ncf_cdf_types[3] = <char>NPY_FLOAT
ufunc__ncf_cdf_types[4] = <char>NPY_FLOAT
ufunc__ncf_cdf_types[5] = <char>NPY_DOUBLE
ufunc__ncf_cdf_types[6] = <char>NPY_DOUBLE
ufunc__ncf_cdf_types[7] = <char>NPY_DOUBLE
ufunc__ncf_cdf_types[8] = <char>NPY_DOUBLE
ufunc__ncf_cdf_types[9] = <char>NPY_DOUBLE
ufunc__ncf_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_cdf_float
ufunc__ncf_cdf_ptr[2*0+1] = <void*>(<char*>"_ncf_cdf")
ufunc__ncf_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_cdf_double
ufunc__ncf_cdf_ptr[2*1+1] = <void*>(<char*>"_ncf_cdf")
ufunc__ncf_cdf_data[0] = &ufunc__ncf_cdf_ptr[2*0]
ufunc__ncf_cdf_data[1] = &ufunc__ncf_cdf_ptr[2*1]
_ncf_cdf = np.PyUFunc_FromFuncAndData(ufunc__ncf_cdf_loops, ufunc__ncf_cdf_data, ufunc__ncf_cdf_types, 2, 4, 1, 0, "_ncf_cdf", ufunc__ncf_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_isf_loops[2]
cdef void *ufunc__ncf_isf_ptr[4]
cdef void *ufunc__ncf_isf_data[2]
cdef char ufunc__ncf_isf_types[10]
cdef char *ufunc__ncf_isf_doc = (
    "_ncf_isf(x, v1, v2, l)\n"
    "\n"
    "Inverse surivial function of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__ncf_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__ncf_isf_types[0] = <char>NPY_FLOAT
ufunc__ncf_isf_types[1] = <char>NPY_FLOAT
ufunc__ncf_isf_types[2] = <char>NPY_FLOAT
ufunc__ncf_isf_types[3] = <char>NPY_FLOAT
ufunc__ncf_isf_types[4] = <char>NPY_FLOAT
ufunc__ncf_isf_types[5] = <char>NPY_DOUBLE
ufunc__ncf_isf_types[6] = <char>NPY_DOUBLE
ufunc__ncf_isf_types[7] = <char>NPY_DOUBLE
ufunc__ncf_isf_types[8] = <char>NPY_DOUBLE
ufunc__ncf_isf_types[9] = <char>NPY_DOUBLE
ufunc__ncf_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_isf_float
ufunc__ncf_isf_ptr[2*0+1] = <void*>(<char*>"_ncf_isf")
ufunc__ncf_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_isf_double
ufunc__ncf_isf_ptr[2*1+1] = <void*>(<char*>"_ncf_isf")
ufunc__ncf_isf_data[0] = &ufunc__ncf_isf_ptr[2*0]
ufunc__ncf_isf_data[1] = &ufunc__ncf_isf_ptr[2*1]
_ncf_isf = np.PyUFunc_FromFuncAndData(ufunc__ncf_isf_loops, ufunc__ncf_isf_data, ufunc__ncf_isf_types, 2, 4, 1, 0, "_ncf_isf", ufunc__ncf_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_kurtosis_excess_loops[2]
cdef void *ufunc__ncf_kurtosis_excess_ptr[4]
cdef void *ufunc__ncf_kurtosis_excess_data[2]
cdef char ufunc__ncf_kurtosis_excess_types[8]
cdef char *ufunc__ncf_kurtosis_excess_doc = (
    "_ncf_kurtosis_excess(v1, v2, l)\n"
    "\n"
    "Kurtosis excess of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_kurtosis_excess_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncf_kurtosis_excess_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncf_kurtosis_excess_types[0] = <char>NPY_FLOAT
ufunc__ncf_kurtosis_excess_types[1] = <char>NPY_FLOAT
ufunc__ncf_kurtosis_excess_types[2] = <char>NPY_FLOAT
ufunc__ncf_kurtosis_excess_types[3] = <char>NPY_FLOAT
ufunc__ncf_kurtosis_excess_types[4] = <char>NPY_DOUBLE
ufunc__ncf_kurtosis_excess_types[5] = <char>NPY_DOUBLE
ufunc__ncf_kurtosis_excess_types[6] = <char>NPY_DOUBLE
ufunc__ncf_kurtosis_excess_types[7] = <char>NPY_DOUBLE
ufunc__ncf_kurtosis_excess_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_kurtosis_excess_float
ufunc__ncf_kurtosis_excess_ptr[2*0+1] = <void*>(<char*>"_ncf_kurtosis_excess")
ufunc__ncf_kurtosis_excess_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_kurtosis_excess_double
ufunc__ncf_kurtosis_excess_ptr[2*1+1] = <void*>(<char*>"_ncf_kurtosis_excess")
ufunc__ncf_kurtosis_excess_data[0] = &ufunc__ncf_kurtosis_excess_ptr[2*0]
ufunc__ncf_kurtosis_excess_data[1] = &ufunc__ncf_kurtosis_excess_ptr[2*1]
_ncf_kurtosis_excess = np.PyUFunc_FromFuncAndData(ufunc__ncf_kurtosis_excess_loops, ufunc__ncf_kurtosis_excess_data, ufunc__ncf_kurtosis_excess_types, 2, 3, 1, 0, "_ncf_kurtosis_excess", ufunc__ncf_kurtosis_excess_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_mean_loops[2]
cdef void *ufunc__ncf_mean_ptr[4]
cdef void *ufunc__ncf_mean_data[2]
cdef char ufunc__ncf_mean_types[8]
cdef char *ufunc__ncf_mean_doc = (
    "_ncf_mean(v1, v2, l)\n"
    "\n"
    "Mean of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_mean_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncf_mean_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncf_mean_types[0] = <char>NPY_FLOAT
ufunc__ncf_mean_types[1] = <char>NPY_FLOAT
ufunc__ncf_mean_types[2] = <char>NPY_FLOAT
ufunc__ncf_mean_types[3] = <char>NPY_FLOAT
ufunc__ncf_mean_types[4] = <char>NPY_DOUBLE
ufunc__ncf_mean_types[5] = <char>NPY_DOUBLE
ufunc__ncf_mean_types[6] = <char>NPY_DOUBLE
ufunc__ncf_mean_types[7] = <char>NPY_DOUBLE
ufunc__ncf_mean_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_mean_float
ufunc__ncf_mean_ptr[2*0+1] = <void*>(<char*>"_ncf_mean")
ufunc__ncf_mean_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_mean_double
ufunc__ncf_mean_ptr[2*1+1] = <void*>(<char*>"_ncf_mean")
ufunc__ncf_mean_data[0] = &ufunc__ncf_mean_ptr[2*0]
ufunc__ncf_mean_data[1] = &ufunc__ncf_mean_ptr[2*1]
_ncf_mean = np.PyUFunc_FromFuncAndData(ufunc__ncf_mean_loops, ufunc__ncf_mean_data, ufunc__ncf_mean_types, 2, 3, 1, 0, "_ncf_mean", ufunc__ncf_mean_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_pdf_loops[2]
cdef void *ufunc__ncf_pdf_ptr[4]
cdef void *ufunc__ncf_pdf_data[2]
cdef char ufunc__ncf_pdf_types[10]
cdef char *ufunc__ncf_pdf_doc = (
    "_ncf_pdf(x, v1, v2, l)\n"
    "\n"
    "Probability density function of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_pdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__ncf_pdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__ncf_pdf_types[0] = <char>NPY_FLOAT
ufunc__ncf_pdf_types[1] = <char>NPY_FLOAT
ufunc__ncf_pdf_types[2] = <char>NPY_FLOAT
ufunc__ncf_pdf_types[3] = <char>NPY_FLOAT
ufunc__ncf_pdf_types[4] = <char>NPY_FLOAT
ufunc__ncf_pdf_types[5] = <char>NPY_DOUBLE
ufunc__ncf_pdf_types[6] = <char>NPY_DOUBLE
ufunc__ncf_pdf_types[7] = <char>NPY_DOUBLE
ufunc__ncf_pdf_types[8] = <char>NPY_DOUBLE
ufunc__ncf_pdf_types[9] = <char>NPY_DOUBLE
ufunc__ncf_pdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_pdf_float
ufunc__ncf_pdf_ptr[2*0+1] = <void*>(<char*>"_ncf_pdf")
ufunc__ncf_pdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_pdf_double
ufunc__ncf_pdf_ptr[2*1+1] = <void*>(<char*>"_ncf_pdf")
ufunc__ncf_pdf_data[0] = &ufunc__ncf_pdf_ptr[2*0]
ufunc__ncf_pdf_data[1] = &ufunc__ncf_pdf_ptr[2*1]
_ncf_pdf = np.PyUFunc_FromFuncAndData(ufunc__ncf_pdf_loops, ufunc__ncf_pdf_data, ufunc__ncf_pdf_types, 2, 4, 1, 0, "_ncf_pdf", ufunc__ncf_pdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_ppf_loops[2]
cdef void *ufunc__ncf_ppf_ptr[4]
cdef void *ufunc__ncf_ppf_data[2]
cdef char ufunc__ncf_ppf_types[10]
cdef char *ufunc__ncf_ppf_doc = (
    "_ncf_ppf(x, v1, v2, l)\n"
    "\n"
    "Percent point function of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__ncf_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__ncf_ppf_types[0] = <char>NPY_FLOAT
ufunc__ncf_ppf_types[1] = <char>NPY_FLOAT
ufunc__ncf_ppf_types[2] = <char>NPY_FLOAT
ufunc__ncf_ppf_types[3] = <char>NPY_FLOAT
ufunc__ncf_ppf_types[4] = <char>NPY_FLOAT
ufunc__ncf_ppf_types[5] = <char>NPY_DOUBLE
ufunc__ncf_ppf_types[6] = <char>NPY_DOUBLE
ufunc__ncf_ppf_types[7] = <char>NPY_DOUBLE
ufunc__ncf_ppf_types[8] = <char>NPY_DOUBLE
ufunc__ncf_ppf_types[9] = <char>NPY_DOUBLE
ufunc__ncf_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_ppf_float
ufunc__ncf_ppf_ptr[2*0+1] = <void*>(<char*>"_ncf_ppf")
ufunc__ncf_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_ppf_double
ufunc__ncf_ppf_ptr[2*1+1] = <void*>(<char*>"_ncf_ppf")
ufunc__ncf_ppf_data[0] = &ufunc__ncf_ppf_ptr[2*0]
ufunc__ncf_ppf_data[1] = &ufunc__ncf_ppf_ptr[2*1]
_ncf_ppf = np.PyUFunc_FromFuncAndData(ufunc__ncf_ppf_loops, ufunc__ncf_ppf_data, ufunc__ncf_ppf_types, 2, 4, 1, 0, "_ncf_ppf", ufunc__ncf_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_sf_loops[2]
cdef void *ufunc__ncf_sf_ptr[4]
cdef void *ufunc__ncf_sf_data[2]
cdef char ufunc__ncf_sf_types[10]
cdef char *ufunc__ncf_sf_doc = (
    "_ncf_sf(x, v1, v2, l)\n"
    "\n"
    "Survival function of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__ncf_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__ncf_sf_types[0] = <char>NPY_FLOAT
ufunc__ncf_sf_types[1] = <char>NPY_FLOAT
ufunc__ncf_sf_types[2] = <char>NPY_FLOAT
ufunc__ncf_sf_types[3] = <char>NPY_FLOAT
ufunc__ncf_sf_types[4] = <char>NPY_FLOAT
ufunc__ncf_sf_types[5] = <char>NPY_DOUBLE
ufunc__ncf_sf_types[6] = <char>NPY_DOUBLE
ufunc__ncf_sf_types[7] = <char>NPY_DOUBLE
ufunc__ncf_sf_types[8] = <char>NPY_DOUBLE
ufunc__ncf_sf_types[9] = <char>NPY_DOUBLE
ufunc__ncf_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_sf_float
ufunc__ncf_sf_ptr[2*0+1] = <void*>(<char*>"_ncf_sf")
ufunc__ncf_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_sf_double
ufunc__ncf_sf_ptr[2*1+1] = <void*>(<char*>"_ncf_sf")
ufunc__ncf_sf_data[0] = &ufunc__ncf_sf_ptr[2*0]
ufunc__ncf_sf_data[1] = &ufunc__ncf_sf_ptr[2*1]
_ncf_sf = np.PyUFunc_FromFuncAndData(ufunc__ncf_sf_loops, ufunc__ncf_sf_data, ufunc__ncf_sf_types, 2, 4, 1, 0, "_ncf_sf", ufunc__ncf_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_skewness_loops[2]
cdef void *ufunc__ncf_skewness_ptr[4]
cdef void *ufunc__ncf_skewness_data[2]
cdef char ufunc__ncf_skewness_types[8]
cdef char *ufunc__ncf_skewness_doc = (
    "_ncf_skewness(v1, v2, l)\n"
    "\n"
    "Skewness of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_skewness_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncf_skewness_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncf_skewness_types[0] = <char>NPY_FLOAT
ufunc__ncf_skewness_types[1] = <char>NPY_FLOAT
ufunc__ncf_skewness_types[2] = <char>NPY_FLOAT
ufunc__ncf_skewness_types[3] = <char>NPY_FLOAT
ufunc__ncf_skewness_types[4] = <char>NPY_DOUBLE
ufunc__ncf_skewness_types[5] = <char>NPY_DOUBLE
ufunc__ncf_skewness_types[6] = <char>NPY_DOUBLE
ufunc__ncf_skewness_types[7] = <char>NPY_DOUBLE
ufunc__ncf_skewness_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_skewness_float
ufunc__ncf_skewness_ptr[2*0+1] = <void*>(<char*>"_ncf_skewness")
ufunc__ncf_skewness_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_skewness_double
ufunc__ncf_skewness_ptr[2*1+1] = <void*>(<char*>"_ncf_skewness")
ufunc__ncf_skewness_data[0] = &ufunc__ncf_skewness_ptr[2*0]
ufunc__ncf_skewness_data[1] = &ufunc__ncf_skewness_ptr[2*1]
_ncf_skewness = np.PyUFunc_FromFuncAndData(ufunc__ncf_skewness_loops, ufunc__ncf_skewness_data, ufunc__ncf_skewness_types, 2, 3, 1, 0, "_ncf_skewness", ufunc__ncf_skewness_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncf_variance_loops[2]
cdef void *ufunc__ncf_variance_ptr[4]
cdef void *ufunc__ncf_variance_data[2]
cdef char ufunc__ncf_variance_types[8]
cdef char *ufunc__ncf_variance_doc = (
    "_ncf_variance(v1, v2, l)\n"
    "\n"
    "Variance of noncentral F-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v1, v2, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncf_variance_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncf_variance_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncf_variance_types[0] = <char>NPY_FLOAT
ufunc__ncf_variance_types[1] = <char>NPY_FLOAT
ufunc__ncf_variance_types[2] = <char>NPY_FLOAT
ufunc__ncf_variance_types[3] = <char>NPY_FLOAT
ufunc__ncf_variance_types[4] = <char>NPY_DOUBLE
ufunc__ncf_variance_types[5] = <char>NPY_DOUBLE
ufunc__ncf_variance_types[6] = <char>NPY_DOUBLE
ufunc__ncf_variance_types[7] = <char>NPY_DOUBLE
ufunc__ncf_variance_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncf_variance_float
ufunc__ncf_variance_ptr[2*0+1] = <void*>(<char*>"_ncf_variance")
ufunc__ncf_variance_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncf_variance_double
ufunc__ncf_variance_ptr[2*1+1] = <void*>(<char*>"_ncf_variance")
ufunc__ncf_variance_data[0] = &ufunc__ncf_variance_ptr[2*0]
ufunc__ncf_variance_data[1] = &ufunc__ncf_variance_ptr[2*1]
_ncf_variance = np.PyUFunc_FromFuncAndData(ufunc__ncf_variance_loops, ufunc__ncf_variance_data, ufunc__ncf_variance_types, 2, 3, 1, 0, "_ncf_variance", ufunc__ncf_variance_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_cdf_loops[2]
cdef void *ufunc__nct_cdf_ptr[4]
cdef void *ufunc__nct_cdf_data[2]
cdef char ufunc__nct_cdf_types[8]
cdef char *ufunc__nct_cdf_doc = (
    "_nct_cdf(x, v, l)\n"
    "\n"
    "Cumulative density function of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nct_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nct_cdf_types[0] = <char>NPY_FLOAT
ufunc__nct_cdf_types[1] = <char>NPY_FLOAT
ufunc__nct_cdf_types[2] = <char>NPY_FLOAT
ufunc__nct_cdf_types[3] = <char>NPY_FLOAT
ufunc__nct_cdf_types[4] = <char>NPY_DOUBLE
ufunc__nct_cdf_types[5] = <char>NPY_DOUBLE
ufunc__nct_cdf_types[6] = <char>NPY_DOUBLE
ufunc__nct_cdf_types[7] = <char>NPY_DOUBLE
ufunc__nct_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_cdf_float
ufunc__nct_cdf_ptr[2*0+1] = <void*>(<char*>"_nct_cdf")
ufunc__nct_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_cdf_double
ufunc__nct_cdf_ptr[2*1+1] = <void*>(<char*>"_nct_cdf")
ufunc__nct_cdf_data[0] = &ufunc__nct_cdf_ptr[2*0]
ufunc__nct_cdf_data[1] = &ufunc__nct_cdf_ptr[2*1]
_nct_cdf = np.PyUFunc_FromFuncAndData(ufunc__nct_cdf_loops, ufunc__nct_cdf_data, ufunc__nct_cdf_types, 2, 3, 1, 0, "_nct_cdf", ufunc__nct_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_isf_loops[2]
cdef void *ufunc__nct_isf_ptr[4]
cdef void *ufunc__nct_isf_data[2]
cdef char ufunc__nct_isf_types[8]
cdef char *ufunc__nct_isf_doc = (
    "_nct_isf(x, v, l)\n"
    "\n"
    "Inverse surivial function of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nct_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nct_isf_types[0] = <char>NPY_FLOAT
ufunc__nct_isf_types[1] = <char>NPY_FLOAT
ufunc__nct_isf_types[2] = <char>NPY_FLOAT
ufunc__nct_isf_types[3] = <char>NPY_FLOAT
ufunc__nct_isf_types[4] = <char>NPY_DOUBLE
ufunc__nct_isf_types[5] = <char>NPY_DOUBLE
ufunc__nct_isf_types[6] = <char>NPY_DOUBLE
ufunc__nct_isf_types[7] = <char>NPY_DOUBLE
ufunc__nct_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_isf_float
ufunc__nct_isf_ptr[2*0+1] = <void*>(<char*>"_nct_isf")
ufunc__nct_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_isf_double
ufunc__nct_isf_ptr[2*1+1] = <void*>(<char*>"_nct_isf")
ufunc__nct_isf_data[0] = &ufunc__nct_isf_ptr[2*0]
ufunc__nct_isf_data[1] = &ufunc__nct_isf_ptr[2*1]
_nct_isf = np.PyUFunc_FromFuncAndData(ufunc__nct_isf_loops, ufunc__nct_isf_data, ufunc__nct_isf_types, 2, 3, 1, 0, "_nct_isf", ufunc__nct_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_kurtosis_excess_loops[2]
cdef void *ufunc__nct_kurtosis_excess_ptr[4]
cdef void *ufunc__nct_kurtosis_excess_data[2]
cdef char ufunc__nct_kurtosis_excess_types[6]
cdef char *ufunc__nct_kurtosis_excess_doc = (
    "_nct_kurtosis_excess(v, l)\n"
    "\n"
    "Kurtosis excess of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_kurtosis_excess_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nct_kurtosis_excess_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nct_kurtosis_excess_types[0] = <char>NPY_FLOAT
ufunc__nct_kurtosis_excess_types[1] = <char>NPY_FLOAT
ufunc__nct_kurtosis_excess_types[2] = <char>NPY_FLOAT
ufunc__nct_kurtosis_excess_types[3] = <char>NPY_DOUBLE
ufunc__nct_kurtosis_excess_types[4] = <char>NPY_DOUBLE
ufunc__nct_kurtosis_excess_types[5] = <char>NPY_DOUBLE
ufunc__nct_kurtosis_excess_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_kurtosis_excess_float
ufunc__nct_kurtosis_excess_ptr[2*0+1] = <void*>(<char*>"_nct_kurtosis_excess")
ufunc__nct_kurtosis_excess_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_kurtosis_excess_double
ufunc__nct_kurtosis_excess_ptr[2*1+1] = <void*>(<char*>"_nct_kurtosis_excess")
ufunc__nct_kurtosis_excess_data[0] = &ufunc__nct_kurtosis_excess_ptr[2*0]
ufunc__nct_kurtosis_excess_data[1] = &ufunc__nct_kurtosis_excess_ptr[2*1]
_nct_kurtosis_excess = np.PyUFunc_FromFuncAndData(ufunc__nct_kurtosis_excess_loops, ufunc__nct_kurtosis_excess_data, ufunc__nct_kurtosis_excess_types, 2, 2, 1, 0, "_nct_kurtosis_excess", ufunc__nct_kurtosis_excess_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_mean_loops[2]
cdef void *ufunc__nct_mean_ptr[4]
cdef void *ufunc__nct_mean_data[2]
cdef char ufunc__nct_mean_types[6]
cdef char *ufunc__nct_mean_doc = (
    "_nct_mean(v, l)\n"
    "\n"
    "Mean of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_mean_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nct_mean_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nct_mean_types[0] = <char>NPY_FLOAT
ufunc__nct_mean_types[1] = <char>NPY_FLOAT
ufunc__nct_mean_types[2] = <char>NPY_FLOAT
ufunc__nct_mean_types[3] = <char>NPY_DOUBLE
ufunc__nct_mean_types[4] = <char>NPY_DOUBLE
ufunc__nct_mean_types[5] = <char>NPY_DOUBLE
ufunc__nct_mean_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_mean_float
ufunc__nct_mean_ptr[2*0+1] = <void*>(<char*>"_nct_mean")
ufunc__nct_mean_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_mean_double
ufunc__nct_mean_ptr[2*1+1] = <void*>(<char*>"_nct_mean")
ufunc__nct_mean_data[0] = &ufunc__nct_mean_ptr[2*0]
ufunc__nct_mean_data[1] = &ufunc__nct_mean_ptr[2*1]
_nct_mean = np.PyUFunc_FromFuncAndData(ufunc__nct_mean_loops, ufunc__nct_mean_data, ufunc__nct_mean_types, 2, 2, 1, 0, "_nct_mean", ufunc__nct_mean_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_ppf_loops[2]
cdef void *ufunc__nct_ppf_ptr[4]
cdef void *ufunc__nct_ppf_data[2]
cdef char ufunc__nct_ppf_types[8]
cdef char *ufunc__nct_ppf_doc = (
    "_nct_ppf(x, v, l)\n"
    "\n"
    "Percent point function of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nct_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nct_ppf_types[0] = <char>NPY_FLOAT
ufunc__nct_ppf_types[1] = <char>NPY_FLOAT
ufunc__nct_ppf_types[2] = <char>NPY_FLOAT
ufunc__nct_ppf_types[3] = <char>NPY_FLOAT
ufunc__nct_ppf_types[4] = <char>NPY_DOUBLE
ufunc__nct_ppf_types[5] = <char>NPY_DOUBLE
ufunc__nct_ppf_types[6] = <char>NPY_DOUBLE
ufunc__nct_ppf_types[7] = <char>NPY_DOUBLE
ufunc__nct_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_ppf_float
ufunc__nct_ppf_ptr[2*0+1] = <void*>(<char*>"_nct_ppf")
ufunc__nct_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_ppf_double
ufunc__nct_ppf_ptr[2*1+1] = <void*>(<char*>"_nct_ppf")
ufunc__nct_ppf_data[0] = &ufunc__nct_ppf_ptr[2*0]
ufunc__nct_ppf_data[1] = &ufunc__nct_ppf_ptr[2*1]
_nct_ppf = np.PyUFunc_FromFuncAndData(ufunc__nct_ppf_loops, ufunc__nct_ppf_data, ufunc__nct_ppf_types, 2, 3, 1, 0, "_nct_ppf", ufunc__nct_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_sf_loops[2]
cdef void *ufunc__nct_sf_ptr[4]
cdef void *ufunc__nct_sf_data[2]
cdef char ufunc__nct_sf_types[8]
cdef char *ufunc__nct_sf_doc = (
    "_nct_sf(x, v, l)\n"
    "\n"
    "Survival function of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__nct_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__nct_sf_types[0] = <char>NPY_FLOAT
ufunc__nct_sf_types[1] = <char>NPY_FLOAT
ufunc__nct_sf_types[2] = <char>NPY_FLOAT
ufunc__nct_sf_types[3] = <char>NPY_FLOAT
ufunc__nct_sf_types[4] = <char>NPY_DOUBLE
ufunc__nct_sf_types[5] = <char>NPY_DOUBLE
ufunc__nct_sf_types[6] = <char>NPY_DOUBLE
ufunc__nct_sf_types[7] = <char>NPY_DOUBLE
ufunc__nct_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_sf_float
ufunc__nct_sf_ptr[2*0+1] = <void*>(<char*>"_nct_sf")
ufunc__nct_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_sf_double
ufunc__nct_sf_ptr[2*1+1] = <void*>(<char*>"_nct_sf")
ufunc__nct_sf_data[0] = &ufunc__nct_sf_ptr[2*0]
ufunc__nct_sf_data[1] = &ufunc__nct_sf_ptr[2*1]
_nct_sf = np.PyUFunc_FromFuncAndData(ufunc__nct_sf_loops, ufunc__nct_sf_data, ufunc__nct_sf_types, 2, 3, 1, 0, "_nct_sf", ufunc__nct_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_skewness_loops[2]
cdef void *ufunc__nct_skewness_ptr[4]
cdef void *ufunc__nct_skewness_data[2]
cdef char ufunc__nct_skewness_types[6]
cdef char *ufunc__nct_skewness_doc = (
    "_nct_skewness(v, l)\n"
    "\n"
    "Skewness of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_skewness_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nct_skewness_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nct_skewness_types[0] = <char>NPY_FLOAT
ufunc__nct_skewness_types[1] = <char>NPY_FLOAT
ufunc__nct_skewness_types[2] = <char>NPY_FLOAT
ufunc__nct_skewness_types[3] = <char>NPY_DOUBLE
ufunc__nct_skewness_types[4] = <char>NPY_DOUBLE
ufunc__nct_skewness_types[5] = <char>NPY_DOUBLE
ufunc__nct_skewness_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_skewness_float
ufunc__nct_skewness_ptr[2*0+1] = <void*>(<char*>"_nct_skewness")
ufunc__nct_skewness_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_skewness_double
ufunc__nct_skewness_ptr[2*1+1] = <void*>(<char*>"_nct_skewness")
ufunc__nct_skewness_data[0] = &ufunc__nct_skewness_ptr[2*0]
ufunc__nct_skewness_data[1] = &ufunc__nct_skewness_ptr[2*1]
_nct_skewness = np.PyUFunc_FromFuncAndData(ufunc__nct_skewness_loops, ufunc__nct_skewness_data, ufunc__nct_skewness_types, 2, 2, 1, 0, "_nct_skewness", ufunc__nct_skewness_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__nct_variance_loops[2]
cdef void *ufunc__nct_variance_ptr[4]
cdef void *ufunc__nct_variance_data[2]
cdef char ufunc__nct_variance_types[6]
cdef char *ufunc__nct_variance_doc = (
    "_nct_variance(v, l)\n"
    "\n"
    "Variance of noncentral t-distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Positive, real-valued parameters\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__nct_variance_loops[0] = <np.PyUFuncGenericFunction>loop_f_ff__As_ff_f
ufunc__nct_variance_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__nct_variance_types[0] = <char>NPY_FLOAT
ufunc__nct_variance_types[1] = <char>NPY_FLOAT
ufunc__nct_variance_types[2] = <char>NPY_FLOAT
ufunc__nct_variance_types[3] = <char>NPY_DOUBLE
ufunc__nct_variance_types[4] = <char>NPY_DOUBLE
ufunc__nct_variance_types[5] = <char>NPY_DOUBLE
ufunc__nct_variance_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_nct_variance_float
ufunc__nct_variance_ptr[2*0+1] = <void*>(<char*>"_nct_variance")
ufunc__nct_variance_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_nct_variance_double
ufunc__nct_variance_ptr[2*1+1] = <void*>(<char*>"_nct_variance")
ufunc__nct_variance_data[0] = &ufunc__nct_variance_ptr[2*0]
ufunc__nct_variance_data[1] = &ufunc__nct_variance_ptr[2*1]
_nct_variance = np.PyUFunc_FromFuncAndData(ufunc__nct_variance_loops, ufunc__nct_variance_data, ufunc__nct_variance_types, 2, 2, 1, 0, "_nct_variance", ufunc__nct_variance_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncx2_cdf_loops[2]
cdef void *ufunc__ncx2_cdf_ptr[4]
cdef void *ufunc__ncx2_cdf_data[2]
cdef char ufunc__ncx2_cdf_types[8]
cdef char *ufunc__ncx2_cdf_doc = (
    "_ncx2_cdf(x, k, l)\n"
    "\n"
    "Cumulative density function of Non-central chi-squared distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "k, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncx2_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncx2_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncx2_cdf_types[0] = <char>NPY_FLOAT
ufunc__ncx2_cdf_types[1] = <char>NPY_FLOAT
ufunc__ncx2_cdf_types[2] = <char>NPY_FLOAT
ufunc__ncx2_cdf_types[3] = <char>NPY_FLOAT
ufunc__ncx2_cdf_types[4] = <char>NPY_DOUBLE
ufunc__ncx2_cdf_types[5] = <char>NPY_DOUBLE
ufunc__ncx2_cdf_types[6] = <char>NPY_DOUBLE
ufunc__ncx2_cdf_types[7] = <char>NPY_DOUBLE
ufunc__ncx2_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncx2_cdf_float
ufunc__ncx2_cdf_ptr[2*0+1] = <void*>(<char*>"_ncx2_cdf")
ufunc__ncx2_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncx2_cdf_double
ufunc__ncx2_cdf_ptr[2*1+1] = <void*>(<char*>"_ncx2_cdf")
ufunc__ncx2_cdf_data[0] = &ufunc__ncx2_cdf_ptr[2*0]
ufunc__ncx2_cdf_data[1] = &ufunc__ncx2_cdf_ptr[2*1]
_ncx2_cdf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_cdf_loops, ufunc__ncx2_cdf_data, ufunc__ncx2_cdf_types, 2, 3, 1, 0, "_ncx2_cdf", ufunc__ncx2_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncx2_isf_loops[2]
cdef void *ufunc__ncx2_isf_ptr[4]
cdef void *ufunc__ncx2_isf_data[2]
cdef char ufunc__ncx2_isf_types[8]
cdef char *ufunc__ncx2_isf_doc = (
    "_ncx2_isf(x, k, l)\n"
    "\n"
    "Inverse survival function of Non-central chi-squared distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "k, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncx2_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncx2_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncx2_isf_types[0] = <char>NPY_FLOAT
ufunc__ncx2_isf_types[1] = <char>NPY_FLOAT
ufunc__ncx2_isf_types[2] = <char>NPY_FLOAT
ufunc__ncx2_isf_types[3] = <char>NPY_FLOAT
ufunc__ncx2_isf_types[4] = <char>NPY_DOUBLE
ufunc__ncx2_isf_types[5] = <char>NPY_DOUBLE
ufunc__ncx2_isf_types[6] = <char>NPY_DOUBLE
ufunc__ncx2_isf_types[7] = <char>NPY_DOUBLE
ufunc__ncx2_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncx2_isf_float
ufunc__ncx2_isf_ptr[2*0+1] = <void*>(<char*>"_ncx2_isf")
ufunc__ncx2_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncx2_isf_double
ufunc__ncx2_isf_ptr[2*1+1] = <void*>(<char*>"_ncx2_isf")
ufunc__ncx2_isf_data[0] = &ufunc__ncx2_isf_ptr[2*0]
ufunc__ncx2_isf_data[1] = &ufunc__ncx2_isf_ptr[2*1]
_ncx2_isf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_isf_loops, ufunc__ncx2_isf_data, ufunc__ncx2_isf_types, 2, 3, 1, 0, "_ncx2_isf", ufunc__ncx2_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncx2_pdf_loops[2]
cdef void *ufunc__ncx2_pdf_ptr[4]
cdef void *ufunc__ncx2_pdf_data[2]
cdef char ufunc__ncx2_pdf_types[8]
cdef char *ufunc__ncx2_pdf_doc = (
    "_ncx2_pdf(x, k, l)\n"
    "\n"
    "Probability density function of Non-central chi-squared distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "k, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncx2_pdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncx2_pdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncx2_pdf_types[0] = <char>NPY_FLOAT
ufunc__ncx2_pdf_types[1] = <char>NPY_FLOAT
ufunc__ncx2_pdf_types[2] = <char>NPY_FLOAT
ufunc__ncx2_pdf_types[3] = <char>NPY_FLOAT
ufunc__ncx2_pdf_types[4] = <char>NPY_DOUBLE
ufunc__ncx2_pdf_types[5] = <char>NPY_DOUBLE
ufunc__ncx2_pdf_types[6] = <char>NPY_DOUBLE
ufunc__ncx2_pdf_types[7] = <char>NPY_DOUBLE
ufunc__ncx2_pdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncx2_pdf_float
ufunc__ncx2_pdf_ptr[2*0+1] = <void*>(<char*>"_ncx2_pdf")
ufunc__ncx2_pdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncx2_pdf_double
ufunc__ncx2_pdf_ptr[2*1+1] = <void*>(<char*>"_ncx2_pdf")
ufunc__ncx2_pdf_data[0] = &ufunc__ncx2_pdf_ptr[2*0]
ufunc__ncx2_pdf_data[1] = &ufunc__ncx2_pdf_ptr[2*1]
_ncx2_pdf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_pdf_loops, ufunc__ncx2_pdf_data, ufunc__ncx2_pdf_types, 2, 3, 1, 0, "_ncx2_pdf", ufunc__ncx2_pdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncx2_ppf_loops[2]
cdef void *ufunc__ncx2_ppf_ptr[4]
cdef void *ufunc__ncx2_ppf_data[2]
cdef char ufunc__ncx2_ppf_types[8]
cdef char *ufunc__ncx2_ppf_doc = (
    "_ncx2_ppf(x, k, l)\n"
    "\n"
    "Percent point function of Non-central chi-squared distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "k, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncx2_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncx2_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncx2_ppf_types[0] = <char>NPY_FLOAT
ufunc__ncx2_ppf_types[1] = <char>NPY_FLOAT
ufunc__ncx2_ppf_types[2] = <char>NPY_FLOAT
ufunc__ncx2_ppf_types[3] = <char>NPY_FLOAT
ufunc__ncx2_ppf_types[4] = <char>NPY_DOUBLE
ufunc__ncx2_ppf_types[5] = <char>NPY_DOUBLE
ufunc__ncx2_ppf_types[6] = <char>NPY_DOUBLE
ufunc__ncx2_ppf_types[7] = <char>NPY_DOUBLE
ufunc__ncx2_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncx2_ppf_float
ufunc__ncx2_ppf_ptr[2*0+1] = <void*>(<char*>"_ncx2_ppf")
ufunc__ncx2_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncx2_ppf_double
ufunc__ncx2_ppf_ptr[2*1+1] = <void*>(<char*>"_ncx2_ppf")
ufunc__ncx2_ppf_data[0] = &ufunc__ncx2_ppf_ptr[2*0]
ufunc__ncx2_ppf_data[1] = &ufunc__ncx2_ppf_ptr[2*1]
_ncx2_ppf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_ppf_loops, ufunc__ncx2_ppf_data, ufunc__ncx2_ppf_types, 2, 3, 1, 0, "_ncx2_ppf", ufunc__ncx2_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__ncx2_sf_loops[2]
cdef void *ufunc__ncx2_sf_ptr[4]
cdef void *ufunc__ncx2_sf_data[2]
cdef char ufunc__ncx2_sf_types[8]
cdef char *ufunc__ncx2_sf_doc = (
    "_ncx2_sf(x, k, l)\n"
    "\n"
    "Survival function of Non-central chi-squared distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Positive real-valued\n"
    "k, l : array_like\n"
    "    Positive, real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__ncx2_sf_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc__ncx2_sf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc__ncx2_sf_types[0] = <char>NPY_FLOAT
ufunc__ncx2_sf_types[1] = <char>NPY_FLOAT
ufunc__ncx2_sf_types[2] = <char>NPY_FLOAT
ufunc__ncx2_sf_types[3] = <char>NPY_FLOAT
ufunc__ncx2_sf_types[4] = <char>NPY_DOUBLE
ufunc__ncx2_sf_types[5] = <char>NPY_DOUBLE
ufunc__ncx2_sf_types[6] = <char>NPY_DOUBLE
ufunc__ncx2_sf_types[7] = <char>NPY_DOUBLE
ufunc__ncx2_sf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ncx2_sf_float
ufunc__ncx2_sf_ptr[2*0+1] = <void*>(<char*>"_ncx2_sf")
ufunc__ncx2_sf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ncx2_sf_double
ufunc__ncx2_sf_ptr[2*1+1] = <void*>(<char*>"_ncx2_sf")
ufunc__ncx2_sf_data[0] = &ufunc__ncx2_sf_ptr[2*0]
ufunc__ncx2_sf_data[1] = &ufunc__ncx2_sf_ptr[2*1]
_ncx2_sf = np.PyUFunc_FromFuncAndData(ufunc__ncx2_sf_loops, ufunc__ncx2_sf_data, ufunc__ncx2_sf_types, 2, 3, 1, 0, "_ncx2_sf", ufunc__ncx2_sf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__riemann_zeta_loops[2]
cdef void *ufunc__riemann_zeta_ptr[4]
cdef void *ufunc__riemann_zeta_data[2]
cdef char ufunc__riemann_zeta_types[4]
cdef char *ufunc__riemann_zeta_doc = (
    "Internal function, use `zeta` instead.")
ufunc__riemann_zeta_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc__riemann_zeta_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc__riemann_zeta_types[0] = <char>NPY_FLOAT
ufunc__riemann_zeta_types[1] = <char>NPY_FLOAT
ufunc__riemann_zeta_types[2] = <char>NPY_DOUBLE
ufunc__riemann_zeta_types[3] = <char>NPY_DOUBLE
ufunc__riemann_zeta_ptr[2*0] = <void*>_func_cephes_riemann_zeta
ufunc__riemann_zeta_ptr[2*0+1] = <void*>(<char*>"_riemann_zeta")
ufunc__riemann_zeta_ptr[2*1] = <void*>_func_cephes_riemann_zeta
ufunc__riemann_zeta_ptr[2*1+1] = <void*>(<char*>"_riemann_zeta")
ufunc__riemann_zeta_data[0] = &ufunc__riemann_zeta_ptr[2*0]
ufunc__riemann_zeta_data[1] = &ufunc__riemann_zeta_ptr[2*1]
_riemann_zeta = np.PyUFunc_FromFuncAndData(ufunc__riemann_zeta_loops, ufunc__riemann_zeta_data, ufunc__riemann_zeta_types, 2, 1, 1, 0, "_riemann_zeta", ufunc__riemann_zeta_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__sf_error_test_function_loops[1]
cdef void *ufunc__sf_error_test_function_ptr[2]
cdef void *ufunc__sf_error_test_function_data[1]
cdef char ufunc__sf_error_test_function_types[2]
cdef char *ufunc__sf_error_test_function_doc = (
    "Private function; do not use.")
ufunc__sf_error_test_function_loops[0] = <np.PyUFuncGenericFunction>loop_i_i__As_l_l
ufunc__sf_error_test_function_types[0] = <char>NPY_LONG
ufunc__sf_error_test_function_types[1] = <char>NPY_LONG
ufunc__sf_error_test_function_ptr[2*0] = <void*>_func__sf_error_test_function
ufunc__sf_error_test_function_ptr[2*0+1] = <void*>(<char*>"_sf_error_test_function")
ufunc__sf_error_test_function_data[0] = &ufunc__sf_error_test_function_ptr[2*0]
_sf_error_test_function = np.PyUFunc_FromFuncAndData(ufunc__sf_error_test_function_loops, ufunc__sf_error_test_function_data, ufunc__sf_error_test_function_types, 1, 1, 1, 0, "_sf_error_test_function", ufunc__sf_error_test_function_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__skewnorm_cdf_loops[2]
cdef void *ufunc__skewnorm_cdf_ptr[4]
cdef void *ufunc__skewnorm_cdf_data[2]
cdef char ufunc__skewnorm_cdf_types[10]
cdef char *ufunc__skewnorm_cdf_doc = (
    "_skewnorm_cdf(x, l, sc, sh)\n"
    "\n"
    "Cumulative density function of skewnorm distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "sc : array_like\n"
    "    Positive, Real-valued parameters\n"
    "sh : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__skewnorm_cdf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__skewnorm_cdf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__skewnorm_cdf_types[0] = <char>NPY_FLOAT
ufunc__skewnorm_cdf_types[1] = <char>NPY_FLOAT
ufunc__skewnorm_cdf_types[2] = <char>NPY_FLOAT
ufunc__skewnorm_cdf_types[3] = <char>NPY_FLOAT
ufunc__skewnorm_cdf_types[4] = <char>NPY_FLOAT
ufunc__skewnorm_cdf_types[5] = <char>NPY_DOUBLE
ufunc__skewnorm_cdf_types[6] = <char>NPY_DOUBLE
ufunc__skewnorm_cdf_types[7] = <char>NPY_DOUBLE
ufunc__skewnorm_cdf_types[8] = <char>NPY_DOUBLE
ufunc__skewnorm_cdf_types[9] = <char>NPY_DOUBLE
ufunc__skewnorm_cdf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_cdf_float
ufunc__skewnorm_cdf_ptr[2*0+1] = <void*>(<char*>"_skewnorm_cdf")
ufunc__skewnorm_cdf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_cdf_double
ufunc__skewnorm_cdf_ptr[2*1+1] = <void*>(<char*>"_skewnorm_cdf")
ufunc__skewnorm_cdf_data[0] = &ufunc__skewnorm_cdf_ptr[2*0]
ufunc__skewnorm_cdf_data[1] = &ufunc__skewnorm_cdf_ptr[2*1]
_skewnorm_cdf = np.PyUFunc_FromFuncAndData(ufunc__skewnorm_cdf_loops, ufunc__skewnorm_cdf_data, ufunc__skewnorm_cdf_types, 2, 4, 1, 0, "_skewnorm_cdf", ufunc__skewnorm_cdf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__skewnorm_isf_loops[2]
cdef void *ufunc__skewnorm_isf_ptr[4]
cdef void *ufunc__skewnorm_isf_data[2]
cdef char ufunc__skewnorm_isf_types[10]
cdef char *ufunc__skewnorm_isf_doc = (
    "_skewnorm_isf(x, l, sc, sh)\n"
    "\n"
    "Inverse surivial function of skewnorm distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "sc : array_like\n"
    "    Positive, Real-valued parameters\n"
    "sh : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__skewnorm_isf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__skewnorm_isf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__skewnorm_isf_types[0] = <char>NPY_FLOAT
ufunc__skewnorm_isf_types[1] = <char>NPY_FLOAT
ufunc__skewnorm_isf_types[2] = <char>NPY_FLOAT
ufunc__skewnorm_isf_types[3] = <char>NPY_FLOAT
ufunc__skewnorm_isf_types[4] = <char>NPY_FLOAT
ufunc__skewnorm_isf_types[5] = <char>NPY_DOUBLE
ufunc__skewnorm_isf_types[6] = <char>NPY_DOUBLE
ufunc__skewnorm_isf_types[7] = <char>NPY_DOUBLE
ufunc__skewnorm_isf_types[8] = <char>NPY_DOUBLE
ufunc__skewnorm_isf_types[9] = <char>NPY_DOUBLE
ufunc__skewnorm_isf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_isf_float
ufunc__skewnorm_isf_ptr[2*0+1] = <void*>(<char*>"_skewnorm_isf")
ufunc__skewnorm_isf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_isf_double
ufunc__skewnorm_isf_ptr[2*1+1] = <void*>(<char*>"_skewnorm_isf")
ufunc__skewnorm_isf_data[0] = &ufunc__skewnorm_isf_ptr[2*0]
ufunc__skewnorm_isf_data[1] = &ufunc__skewnorm_isf_ptr[2*1]
_skewnorm_isf = np.PyUFunc_FromFuncAndData(ufunc__skewnorm_isf_loops, ufunc__skewnorm_isf_data, ufunc__skewnorm_isf_types, 2, 4, 1, 0, "_skewnorm_isf", ufunc__skewnorm_isf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__skewnorm_ppf_loops[2]
cdef void *ufunc__skewnorm_ppf_ptr[4]
cdef void *ufunc__skewnorm_ppf_data[2]
cdef char ufunc__skewnorm_ppf_types[10]
cdef char *ufunc__skewnorm_ppf_doc = (
    "_skewnorm_ppf(x, l, sc, sh)\n"
    "\n"
    "Percent point function of skewnorm distribution.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real-valued\n"
    "l : array_like\n"
    "    Real-valued parameters\n"
    "sc : array_like\n"
    "    Positive, Real-valued parameters\n"
    "sh : array_like\n"
    "    Real-valued parameters\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray")
ufunc__skewnorm_ppf_loops[0] = <np.PyUFuncGenericFunction>loop_f_ffff__As_ffff_f
ufunc__skewnorm_ppf_loops[1] = <np.PyUFuncGenericFunction>loop_d_dddd__As_dddd_d
ufunc__skewnorm_ppf_types[0] = <char>NPY_FLOAT
ufunc__skewnorm_ppf_types[1] = <char>NPY_FLOAT
ufunc__skewnorm_ppf_types[2] = <char>NPY_FLOAT
ufunc__skewnorm_ppf_types[3] = <char>NPY_FLOAT
ufunc__skewnorm_ppf_types[4] = <char>NPY_FLOAT
ufunc__skewnorm_ppf_types[5] = <char>NPY_DOUBLE
ufunc__skewnorm_ppf_types[6] = <char>NPY_DOUBLE
ufunc__skewnorm_ppf_types[7] = <char>NPY_DOUBLE
ufunc__skewnorm_ppf_types[8] = <char>NPY_DOUBLE
ufunc__skewnorm_ppf_types[9] = <char>NPY_DOUBLE
ufunc__skewnorm_ppf_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_ppf_float
ufunc__skewnorm_ppf_ptr[2*0+1] = <void*>(<char*>"_skewnorm_ppf")
ufunc__skewnorm_ppf_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_skewnorm_ppf_double
ufunc__skewnorm_ppf_ptr[2*1+1] = <void*>(<char*>"_skewnorm_ppf")
ufunc__skewnorm_ppf_data[0] = &ufunc__skewnorm_ppf_ptr[2*0]
ufunc__skewnorm_ppf_data[1] = &ufunc__skewnorm_ppf_ptr[2*1]
_skewnorm_ppf = np.PyUFunc_FromFuncAndData(ufunc__skewnorm_ppf_loops, ufunc__skewnorm_ppf_data, ufunc__skewnorm_ppf_types, 2, 4, 1, 0, "_skewnorm_ppf", ufunc__skewnorm_ppf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovc_loops[3]
cdef void *ufunc__smirnovc_ptr[6]
cdef void *ufunc__smirnovc_data[3]
cdef char ufunc__smirnovc_types[9]
cdef char *ufunc__smirnovc_doc = (
    "_smirnovc(n, d)\n"
    " Internal function, do not use.")
ufunc__smirnovc_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc__smirnovc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovc_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovc_types[0] = <char>NPY_INTP
ufunc__smirnovc_types[1] = <char>NPY_DOUBLE
ufunc__smirnovc_types[2] = <char>NPY_DOUBLE
ufunc__smirnovc_types[3] = <char>NPY_FLOAT
ufunc__smirnovc_types[4] = <char>NPY_FLOAT
ufunc__smirnovc_types[5] = <char>NPY_FLOAT
ufunc__smirnovc_types[6] = <char>NPY_DOUBLE
ufunc__smirnovc_types[7] = <char>NPY_DOUBLE
ufunc__smirnovc_types[8] = <char>NPY_DOUBLE
ufunc__smirnovc_ptr[2*0] = <void*>_func_cephes_smirnovc_wrap
ufunc__smirnovc_ptr[2*0+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_ptr[2*1] = <void*>_func_smirnovc_unsafe
ufunc__smirnovc_ptr[2*1+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_ptr[2*2] = <void*>_func_smirnovc_unsafe
ufunc__smirnovc_ptr[2*2+1] = <void*>(<char*>"_smirnovc")
ufunc__smirnovc_data[0] = &ufunc__smirnovc_ptr[2*0]
ufunc__smirnovc_data[1] = &ufunc__smirnovc_ptr[2*1]
ufunc__smirnovc_data[2] = &ufunc__smirnovc_ptr[2*2]
_smirnovc = np.PyUFunc_FromFuncAndData(ufunc__smirnovc_loops, ufunc__smirnovc_data, ufunc__smirnovc_types, 3, 2, 1, 0, "_smirnovc", ufunc__smirnovc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovci_loops[3]
cdef void *ufunc__smirnovci_ptr[6]
cdef void *ufunc__smirnovci_data[3]
cdef char ufunc__smirnovci_types[9]
cdef char *ufunc__smirnovci_doc = (
    "Internal function, do not use.")
ufunc__smirnovci_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc__smirnovci_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovci_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovci_types[0] = <char>NPY_INTP
ufunc__smirnovci_types[1] = <char>NPY_DOUBLE
ufunc__smirnovci_types[2] = <char>NPY_DOUBLE
ufunc__smirnovci_types[3] = <char>NPY_FLOAT
ufunc__smirnovci_types[4] = <char>NPY_FLOAT
ufunc__smirnovci_types[5] = <char>NPY_FLOAT
ufunc__smirnovci_types[6] = <char>NPY_DOUBLE
ufunc__smirnovci_types[7] = <char>NPY_DOUBLE
ufunc__smirnovci_types[8] = <char>NPY_DOUBLE
ufunc__smirnovci_ptr[2*0] = <void*>_func_cephes_smirnovci_wrap
ufunc__smirnovci_ptr[2*0+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_ptr[2*1] = <void*>_func_smirnovci_unsafe
ufunc__smirnovci_ptr[2*1+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_ptr[2*2] = <void*>_func_smirnovci_unsafe
ufunc__smirnovci_ptr[2*2+1] = <void*>(<char*>"_smirnovci")
ufunc__smirnovci_data[0] = &ufunc__smirnovci_ptr[2*0]
ufunc__smirnovci_data[1] = &ufunc__smirnovci_ptr[2*1]
ufunc__smirnovci_data[2] = &ufunc__smirnovci_ptr[2*2]
_smirnovci = np.PyUFunc_FromFuncAndData(ufunc__smirnovci_loops, ufunc__smirnovci_data, ufunc__smirnovci_types, 3, 2, 1, 0, "_smirnovci", ufunc__smirnovci_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__smirnovp_loops[3]
cdef void *ufunc__smirnovp_ptr[6]
cdef void *ufunc__smirnovp_data[3]
cdef char ufunc__smirnovp_types[9]
cdef char *ufunc__smirnovp_doc = (
    "_smirnovp(n, p)\n"
    " Internal function, do not use.")
ufunc__smirnovp_loops[0] = <np.PyUFuncGenericFunction>loop_d_pd__As_pd_d
ufunc__smirnovp_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__smirnovp_loops[2] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__smirnovp_types[0] = <char>NPY_INTP
ufunc__smirnovp_types[1] = <char>NPY_DOUBLE
ufunc__smirnovp_types[2] = <char>NPY_DOUBLE
ufunc__smirnovp_types[3] = <char>NPY_FLOAT
ufunc__smirnovp_types[4] = <char>NPY_FLOAT
ufunc__smirnovp_types[5] = <char>NPY_FLOAT
ufunc__smirnovp_types[6] = <char>NPY_DOUBLE
ufunc__smirnovp_types[7] = <char>NPY_DOUBLE
ufunc__smirnovp_types[8] = <char>NPY_DOUBLE
ufunc__smirnovp_ptr[2*0] = <void*>_func_cephes_smirnovp_wrap
ufunc__smirnovp_ptr[2*0+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_ptr[2*1] = <void*>_func_smirnovp_unsafe
ufunc__smirnovp_ptr[2*1+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_ptr[2*2] = <void*>_func_smirnovp_unsafe
ufunc__smirnovp_ptr[2*2+1] = <void*>(<char*>"_smirnovp")
ufunc__smirnovp_data[0] = &ufunc__smirnovp_ptr[2*0]
ufunc__smirnovp_data[1] = &ufunc__smirnovp_ptr[2*1]
ufunc__smirnovp_data[2] = &ufunc__smirnovp_ptr[2*2]
_smirnovp = np.PyUFunc_FromFuncAndData(ufunc__smirnovp_loops, ufunc__smirnovp_data, ufunc__smirnovp_types, 3, 2, 1, 0, "_smirnovp", ufunc__smirnovp_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__stirling2_inexact_loops[2]
cdef void *ufunc__stirling2_inexact_ptr[4]
cdef void *ufunc__stirling2_inexact_data[2]
cdef char ufunc__stirling2_inexact_types[6]
cdef char *ufunc__stirling2_inexact_doc = (
    "Internal function, do not use.")
ufunc__stirling2_inexact_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc__stirling2_inexact_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc__stirling2_inexact_types[0] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[1] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[2] = <char>NPY_FLOAT
ufunc__stirling2_inexact_types[3] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_types[4] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_types[5] = <char>NPY_DOUBLE
ufunc__stirling2_inexact_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export__stirling2_inexact
ufunc__stirling2_inexact_ptr[2*0+1] = <void*>(<char*>"_stirling2_inexact")
ufunc__stirling2_inexact_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export__stirling2_inexact
ufunc__stirling2_inexact_ptr[2*1+1] = <void*>(<char*>"_stirling2_inexact")
ufunc__stirling2_inexact_data[0] = &ufunc__stirling2_inexact_ptr[2*0]
ufunc__stirling2_inexact_data[1] = &ufunc__stirling2_inexact_ptr[2*1]
_stirling2_inexact = np.PyUFunc_FromFuncAndData(ufunc__stirling2_inexact_loops, ufunc__stirling2_inexact_data, ufunc__stirling2_inexact_types, 2, 2, 1, 0, "_stirling2_inexact", ufunc__stirling2_inexact_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_asymp_large_z_loops[1]
cdef void *ufunc__struve_asymp_large_z_ptr[2]
cdef void *ufunc__struve_asymp_large_z_data[1]
cdef char ufunc__struve_asymp_large_z_types[5]
cdef char *ufunc__struve_asymp_large_z_doc = (
    "_struve_asymp_large_z(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using asymptotic expansion\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_asymp_large_z_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddp_d_As_ddp_dd
ufunc__struve_asymp_large_z_types[0] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[1] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[2] = <char>NPY_INTP
ufunc__struve_asymp_large_z_types[3] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_types[4] = <char>NPY_DOUBLE
ufunc__struve_asymp_large_z_ptr[2*0] = <void*>_func_cephes__struve_asymp_large_z
ufunc__struve_asymp_large_z_ptr[2*0+1] = <void*>(<char*>"_struve_asymp_large_z")
ufunc__struve_asymp_large_z_data[0] = &ufunc__struve_asymp_large_z_ptr[2*0]
_struve_asymp_large_z = np.PyUFunc_FromFuncAndData(ufunc__struve_asymp_large_z_loops, ufunc__struve_asymp_large_z_data, ufunc__struve_asymp_large_z_types, 1, 3, 2, 0, "_struve_asymp_large_z", ufunc__struve_asymp_large_z_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_bessel_series_loops[1]
cdef void *ufunc__struve_bessel_series_ptr[2]
cdef void *ufunc__struve_bessel_series_data[1]
cdef char ufunc__struve_bessel_series_types[5]
cdef char *ufunc__struve_bessel_series_doc = (
    "_struve_bessel_series(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using Bessel function series\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_bessel_series_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddp_d_As_ddp_dd
ufunc__struve_bessel_series_types[0] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[1] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[2] = <char>NPY_INTP
ufunc__struve_bessel_series_types[3] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_types[4] = <char>NPY_DOUBLE
ufunc__struve_bessel_series_ptr[2*0] = <void*>_func_cephes__struve_bessel_series
ufunc__struve_bessel_series_ptr[2*0+1] = <void*>(<char*>"_struve_bessel_series")
ufunc__struve_bessel_series_data[0] = &ufunc__struve_bessel_series_ptr[2*0]
_struve_bessel_series = np.PyUFunc_FromFuncAndData(ufunc__struve_bessel_series_loops, ufunc__struve_bessel_series_data, ufunc__struve_bessel_series_types, 1, 3, 2, 0, "_struve_bessel_series", ufunc__struve_bessel_series_doc, 0)

cdef np.PyUFuncGenericFunction ufunc__struve_power_series_loops[1]
cdef void *ufunc__struve_power_series_ptr[2]
cdef void *ufunc__struve_power_series_data[1]
cdef char ufunc__struve_power_series_types[5]
cdef char *ufunc__struve_power_series_doc = (
    "_struve_power_series(v, z, is_h)\n"
    "\n"
    "Internal function for testing `struve` & `modstruve`\n"
    "\n"
    "Evaluates using power series\n"
    "\n"
    "Returns\n"
    "-------\n"
    "v, err")
ufunc__struve_power_series_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddp_d_As_ddp_dd
ufunc__struve_power_series_types[0] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[1] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[2] = <char>NPY_INTP
ufunc__struve_power_series_types[3] = <char>NPY_DOUBLE
ufunc__struve_power_series_types[4] = <char>NPY_DOUBLE
ufunc__struve_power_series_ptr[2*0] = <void*>_func_cephes__struve_power_series
ufunc__struve_power_series_ptr[2*0+1] = <void*>(<char*>"_struve_power_series")
ufunc__struve_power_series_data[0] = &ufunc__struve_power_series_ptr[2*0]
_struve_power_series = np.PyUFunc_FromFuncAndData(ufunc__struve_power_series_loops, ufunc__struve_power_series_data, ufunc__struve_power_series_types, 1, 3, 2, 0, "_struve_power_series", ufunc__struve_power_series_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_agm_loops[2]
cdef void *ufunc_agm_ptr[4]
cdef void *ufunc_agm_data[2]
cdef char ufunc_agm_types[6]
cdef char *ufunc_agm_doc = (
    "agm(a, b, out=None)\n"
    "\n"
    "Compute the arithmetic-geometric mean of `a` and `b`.\n"
    "\n"
    "Start with a_0 = a and b_0 = b and iteratively compute::\n"
    "\n"
    "    a_{n+1} = (a_n + b_n)/2\n"
    "    b_{n+1} = sqrt(a_n*b_n)\n"
    "\n"
    "a_n and b_n converge to the same limit as n increases; their common\n"
    "limit is agm(a, b).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Real values only. If the values are both negative, the result\n"
    "    is negative. If one value is negative and the other is positive,\n"
    "    `nan` is returned.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The arithmetic-geometric mean of `a` and `b`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import agm\n"
    ">>> a, b = 24.0, 6.0\n"
    ">>> agm(a, b)\n"
    "13.458171481725614\n"
    "\n"
    "Compare that result to the iteration:\n"
    "\n"
    ">>> while a != b:\n"
    "...     a, b = (a + b)/2, np.sqrt(a*b)\n"
    "...     print(\"a = %19.16f  b=%19.16f\" % (a, b))\n"
    "...\n"
    "a = 15.0000000000000000  b=12.0000000000000000\n"
    "a = 13.5000000000000000  b=13.4164078649987388\n"
    "a = 13.4582039324993694  b=13.4581390309909850\n"
    "a = 13.4581714817451772  b=13.4581714817060547\n"
    "a = 13.4581714817256159  b=13.4581714817256159\n"
    "\n"
    "When array-like arguments are given, broadcasting applies:\n"
    "\n"
    ">>> a = np.array([[1.5], [3], [6]])  # a has shape (3, 1).\n"
    ">>> b = np.array([6, 12, 24, 48])    # b has shape (4,).\n"
    ">>> agm(a, b)\n"
    "array([[  3.36454287,   5.42363427,   9.05798751,  15.53650756],\n"
    "       [  4.37037309,   6.72908574,  10.84726853,  18.11597502],\n"
    "       [  6.        ,   8.74074619,  13.45817148,  21.69453707]])")
ufunc_agm_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_agm_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_agm_types[0] = <char>NPY_FLOAT
ufunc_agm_types[1] = <char>NPY_FLOAT
ufunc_agm_types[2] = <char>NPY_FLOAT
ufunc_agm_types[3] = <char>NPY_DOUBLE
ufunc_agm_types[4] = <char>NPY_DOUBLE
ufunc_agm_types[5] = <char>NPY_DOUBLE
ufunc_agm_ptr[2*0] = <void*>_func_agm
ufunc_agm_ptr[2*0+1] = <void*>(<char*>"agm")
ufunc_agm_ptr[2*1] = <void*>_func_agm
ufunc_agm_ptr[2*1+1] = <void*>(<char*>"agm")
ufunc_agm_data[0] = &ufunc_agm_ptr[2*0]
ufunc_agm_data[1] = &ufunc_agm_ptr[2*1]
agm = np.PyUFunc_FromFuncAndData(ufunc_agm_loops, ufunc_agm_data, ufunc_agm_types, 2, 2, 1, 0, "agm", ufunc_agm_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtr_loops[3]
cdef void *ufunc_bdtr_ptr[6]
cdef void *ufunc_bdtr_data[3]
cdef char ufunc_bdtr_types[12]
cdef char *ufunc_bdtr_doc = (
    "bdtr(k, n, p, out=None)\n"
    "\n"
    "Binomial distribution cumulative distribution function.\n"
    "\n"
    "Sum of the terms 0 through `floor(k)` of the Binomial probability density.\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtr}(k, n, p) =\n"
    "    \\sum_{j=0}^{\\lfloor k \\rfloor} {{n}\\choose{j}} p^j (1-p)^{n-j}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (double), rounded down to the nearest integer.\n"
    "n : array_like\n"
    "    Number of events (int).\n"
    "p : array_like\n"
    "    Probability of success in a single event (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Probability of `floor(k)` or fewer successes in `n` independent events with\n"
    "    success probabilities of `p`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtr}(k, n, p) =\n"
    "    I_{1 - p}(n - \\lfloor k \\rfloor, \\lfloor k \\rfloor + 1).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dpd__As_dpd_d
ufunc_bdtr_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtr_types[0] = <char>NPY_FLOAT
ufunc_bdtr_types[1] = <char>NPY_FLOAT
ufunc_bdtr_types[2] = <char>NPY_FLOAT
ufunc_bdtr_types[3] = <char>NPY_FLOAT
ufunc_bdtr_types[4] = <char>NPY_DOUBLE
ufunc_bdtr_types[5] = <char>NPY_INTP
ufunc_bdtr_types[6] = <char>NPY_DOUBLE
ufunc_bdtr_types[7] = <char>NPY_DOUBLE
ufunc_bdtr_types[8] = <char>NPY_DOUBLE
ufunc_bdtr_types[9] = <char>NPY_DOUBLE
ufunc_bdtr_types[10] = <char>NPY_DOUBLE
ufunc_bdtr_types[11] = <char>NPY_DOUBLE
ufunc_bdtr_ptr[2*0] = <void*>_func_bdtr_unsafe
ufunc_bdtr_ptr[2*0+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_ptr[2*1] = <void*>_func_cephes_bdtr_wrap
ufunc_bdtr_ptr[2*1+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_ptr[2*2] = <void*>_func_bdtr_unsafe
ufunc_bdtr_ptr[2*2+1] = <void*>(<char*>"bdtr")
ufunc_bdtr_data[0] = &ufunc_bdtr_ptr[2*0]
ufunc_bdtr_data[1] = &ufunc_bdtr_ptr[2*1]
ufunc_bdtr_data[2] = &ufunc_bdtr_ptr[2*2]
bdtr = np.PyUFunc_FromFuncAndData(ufunc_bdtr_loops, ufunc_bdtr_data, ufunc_bdtr_types, 3, 3, 1, 0, "bdtr", ufunc_bdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrc_loops[3]
cdef void *ufunc_bdtrc_ptr[6]
cdef void *ufunc_bdtrc_data[3]
cdef char ufunc_bdtrc_types[12]
cdef char *ufunc_bdtrc_doc = (
    "bdtrc(k, n, p, out=None)\n"
    "\n"
    "Binomial distribution survival function.\n"
    "\n"
    "Sum of the terms `floor(k) + 1` through `n` of the binomial probability\n"
    "density,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtrc}(k, n, p) =\n"
    "    \\sum_{j=\\lfloor k \\rfloor +1}^n {{n}\\choose{j}} p^j (1-p)^{n-j}\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (double), rounded down to nearest integer.\n"
    "n : array_like\n"
    "    Number of events (int)\n"
    "p : array_like\n"
    "    Probability of success in a single event.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Probability of `floor(k) + 1` or more successes in `n` independent\n"
    "    events with success probabilities of `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "betainc\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The terms are not summed directly; instead the regularized incomplete beta\n"
    "function is employed, according to the formula,\n"
    "\n"
    ".. math::\n"
    "    \\mathrm{bdtrc}(k, n, p) = I_{p}(\\lfloor k \\rfloor + 1, n - \\lfloor k \\rfloor).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtrc`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dpd__As_dpd_d
ufunc_bdtrc_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrc_types[0] = <char>NPY_FLOAT
ufunc_bdtrc_types[1] = <char>NPY_FLOAT
ufunc_bdtrc_types[2] = <char>NPY_FLOAT
ufunc_bdtrc_types[3] = <char>NPY_FLOAT
ufunc_bdtrc_types[4] = <char>NPY_DOUBLE
ufunc_bdtrc_types[5] = <char>NPY_INTP
ufunc_bdtrc_types[6] = <char>NPY_DOUBLE
ufunc_bdtrc_types[7] = <char>NPY_DOUBLE
ufunc_bdtrc_types[8] = <char>NPY_DOUBLE
ufunc_bdtrc_types[9] = <char>NPY_DOUBLE
ufunc_bdtrc_types[10] = <char>NPY_DOUBLE
ufunc_bdtrc_types[11] = <char>NPY_DOUBLE
ufunc_bdtrc_ptr[2*0] = <void*>_func_bdtrc_unsafe
ufunc_bdtrc_ptr[2*0+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_ptr[2*1] = <void*>_func_cephes_bdtrc_wrap
ufunc_bdtrc_ptr[2*1+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_ptr[2*2] = <void*>_func_bdtrc_unsafe
ufunc_bdtrc_ptr[2*2+1] = <void*>(<char*>"bdtrc")
ufunc_bdtrc_data[0] = &ufunc_bdtrc_ptr[2*0]
ufunc_bdtrc_data[1] = &ufunc_bdtrc_ptr[2*1]
ufunc_bdtrc_data[2] = &ufunc_bdtrc_ptr[2*2]
bdtrc = np.PyUFunc_FromFuncAndData(ufunc_bdtrc_loops, ufunc_bdtrc_data, ufunc_bdtrc_types, 3, 3, 1, 0, "bdtrc", ufunc_bdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtri_loops[3]
cdef void *ufunc_bdtri_ptr[6]
cdef void *ufunc_bdtri_data[3]
cdef char ufunc_bdtri_types[12]
cdef char *ufunc_bdtri_doc = (
    "bdtri(k, n, y, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `p`.\n"
    "\n"
    "Finds the event probability `p` such that the sum of the terms 0 through\n"
    "`k` of the binomial probability density is equal to the given cumulative\n"
    "probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (float), rounded down to the nearest integer.\n"
    "n : array_like\n"
    "    Number of events (float)\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "p : scalar or ndarray\n"
    "    The event probability such that `bdtr(\\lfloor k \\rfloor, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "betaincinv\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The computation is carried out using the inverse beta integral function\n"
    "and the relation,::\n"
    "\n"
    "    1 - p = betaincinv(n - k, k + 1, y).\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `bdtri`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_bdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dpd__As_dpd_d
ufunc_bdtri_loops[2] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtri_types[0] = <char>NPY_FLOAT
ufunc_bdtri_types[1] = <char>NPY_FLOAT
ufunc_bdtri_types[2] = <char>NPY_FLOAT
ufunc_bdtri_types[3] = <char>NPY_FLOAT
ufunc_bdtri_types[4] = <char>NPY_DOUBLE
ufunc_bdtri_types[5] = <char>NPY_INTP
ufunc_bdtri_types[6] = <char>NPY_DOUBLE
ufunc_bdtri_types[7] = <char>NPY_DOUBLE
ufunc_bdtri_types[8] = <char>NPY_DOUBLE
ufunc_bdtri_types[9] = <char>NPY_DOUBLE
ufunc_bdtri_types[10] = <char>NPY_DOUBLE
ufunc_bdtri_types[11] = <char>NPY_DOUBLE
ufunc_bdtri_ptr[2*0] = <void*>_func_bdtri_unsafe
ufunc_bdtri_ptr[2*0+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_ptr[2*1] = <void*>_func_cephes_bdtri_wrap
ufunc_bdtri_ptr[2*1+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_ptr[2*2] = <void*>_func_bdtri_unsafe
ufunc_bdtri_ptr[2*2+1] = <void*>(<char*>"bdtri")
ufunc_bdtri_data[0] = &ufunc_bdtri_ptr[2*0]
ufunc_bdtri_data[1] = &ufunc_bdtri_ptr[2*1]
ufunc_bdtri_data[2] = &ufunc_bdtri_ptr[2*2]
bdtri = np.PyUFunc_FromFuncAndData(ufunc_bdtri_loops, ufunc_bdtri_data, ufunc_bdtri_types, 3, 3, 1, 0, "bdtri", ufunc_bdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrik_loops[2]
cdef void *ufunc_bdtrik_ptr[4]
cdef void *ufunc_bdtrik_data[2]
cdef char ufunc_bdtrik_types[8]
cdef char *ufunc_bdtrik_doc = (
    "bdtrik(y, n, p, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `k`.\n"
    "\n"
    "Finds the number of successes `k` such that the sum of the terms 0 through\n"
    "`k` of the Binomial probability density for `n` events with probability\n"
    "`p` is equal to the given cumulative probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "n : array_like\n"
    "    Number of events (float).\n"
    "p : array_like\n"
    "    Success probability (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "k : scalar or ndarray\n"
    "    The number of successes `k` such that `bdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n"
    "cumulative incomplete beta distribution.\n"
    "\n"
    "Computation of `k` involves a search for a value that produces the desired\n"
    "value of `y`. The search relies on the monotonicity of `y` with `k`.\n"
    "\n"
    "Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [2] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.")
ufunc_bdtrik_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrik_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrik_types[0] = <char>NPY_FLOAT
ufunc_bdtrik_types[1] = <char>NPY_FLOAT
ufunc_bdtrik_types[2] = <char>NPY_FLOAT
ufunc_bdtrik_types[3] = <char>NPY_FLOAT
ufunc_bdtrik_types[4] = <char>NPY_DOUBLE
ufunc_bdtrik_types[5] = <char>NPY_DOUBLE
ufunc_bdtrik_types[6] = <char>NPY_DOUBLE
ufunc_bdtrik_types[7] = <char>NPY_DOUBLE
ufunc_bdtrik_ptr[2*0] = <void*>_func_bdtrik
ufunc_bdtrik_ptr[2*0+1] = <void*>(<char*>"bdtrik")
ufunc_bdtrik_ptr[2*1] = <void*>_func_bdtrik
ufunc_bdtrik_ptr[2*1+1] = <void*>(<char*>"bdtrik")
ufunc_bdtrik_data[0] = &ufunc_bdtrik_ptr[2*0]
ufunc_bdtrik_data[1] = &ufunc_bdtrik_ptr[2*1]
bdtrik = np.PyUFunc_FromFuncAndData(ufunc_bdtrik_loops, ufunc_bdtrik_data, ufunc_bdtrik_types, 2, 3, 1, 0, "bdtrik", ufunc_bdtrik_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_bdtrin_loops[2]
cdef void *ufunc_bdtrin_ptr[4]
cdef void *ufunc_bdtrin_data[2]
cdef char ufunc_bdtrin_types[8]
cdef char *ufunc_bdtrin_doc = (
    "bdtrin(k, y, p, out=None)\n"
    "\n"
    "Inverse function to `bdtr` with respect to `n`.\n"
    "\n"
    "Finds the number of events `n` such that the sum of the terms 0 through\n"
    "`k` of the Binomial probability density for events with probability `p` is\n"
    "equal to the given cumulative probability `y`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "k : array_like\n"
    "    Number of successes (float).\n"
    "y : array_like\n"
    "    Cumulative probability (probability of `k` or fewer successes in `n`\n"
    "    events).\n"
    "p : array_like\n"
    "    Success probability (float).\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "n : scalar or ndarray\n"
    "    The number of events `n` such that `bdtr(k, n, p) = y`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "bdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Formula 26.5.24 of [1]_ is used to reduce the binomial distribution to the\n"
    "cumulative incomplete beta distribution.\n"
    "\n"
    "Computation of `n` involves a search for a value that produces the desired\n"
    "value of `y`. The search relies on the monotonicity of `y` with `n`.\n"
    "\n"
    "Wrapper for the CDFLIB [2]_ Fortran routine `cdfbin`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Milton Abramowitz and Irene A. Stegun, eds.\n"
    "       Handbook of Mathematical Functions with Formulas,\n"
    "       Graphs, and Mathematical Tables. New York: Dover, 1972.\n"
    ".. [2] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.")
ufunc_bdtrin_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_bdtrin_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_bdtrin_types[0] = <char>NPY_FLOAT
ufunc_bdtrin_types[1] = <char>NPY_FLOAT
ufunc_bdtrin_types[2] = <char>NPY_FLOAT
ufunc_bdtrin_types[3] = <char>NPY_FLOAT
ufunc_bdtrin_types[4] = <char>NPY_DOUBLE
ufunc_bdtrin_types[5] = <char>NPY_DOUBLE
ufunc_bdtrin_types[6] = <char>NPY_DOUBLE
ufunc_bdtrin_types[7] = <char>NPY_DOUBLE
ufunc_bdtrin_ptr[2*0] = <void*>_func_bdtrin
ufunc_bdtrin_ptr[2*0+1] = <void*>(<char*>"bdtrin")
ufunc_bdtrin_ptr[2*1] = <void*>_func_bdtrin
ufunc_bdtrin_ptr[2*1+1] = <void*>(<char*>"bdtrin")
ufunc_bdtrin_data[0] = &ufunc_bdtrin_ptr[2*0]
ufunc_bdtrin_data[1] = &ufunc_bdtrin_ptr[2*1]
bdtrin = np.PyUFunc_FromFuncAndData(ufunc_bdtrin_loops, ufunc_bdtrin_data, ufunc_bdtrin_types, 2, 3, 1, 0, "bdtrin", ufunc_bdtrin_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_besselpoly_loops[2]
cdef void *ufunc_besselpoly_ptr[4]
cdef void *ufunc_besselpoly_data[2]
cdef char ufunc_besselpoly_types[8]
cdef char *ufunc_besselpoly_doc = (
    "besselpoly(a, lmb, nu, out=None)\n"
    "\n"
    "Weighted integral of the Bessel function of the first kind.\n"
    "\n"
    "Computes\n"
    "\n"
    ".. math::\n"
    "\n"
    "   \\int_0^1 x^\\lambda J_\\nu(2 a x) \\, dx\n"
    "\n"
    "where :math:`J_\\nu` is a Bessel function and :math:`\\lambda=lmb`,\n"
    ":math:`\\nu=nu`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Scale factor inside the Bessel function.\n"
    "lmb : array_like\n"
    "    Power of `x`\n"
    "nu : array_like\n"
    "    Order of the Bessel function.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the integral.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/\n"
    "\n"
    "Examples\n"
    "--------\n"
    "Evaluate the function for one parameter set.\n"
    "\n"
    ">>> from scipy.special import besselpoly\n"
    ">>> besselpoly(1, 1, 1)\n"
    "0.24449718372863877\n"
    "\n"
    "Evaluate the function for different scale factors.\n"
    "\n"
    ">>> import numpy as np\n"
    ">>> factors = np.array([0., 3., 6.])\n"
    ">>> besselpoly(factors, 1, 1)\n"
    "array([ 0.        , -0.00549029,  0.00140174])\n"
    "\n"
    "Plot the function for varying powers, orders and scales.\n"
    "\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> fig, ax = plt.subplots()\n"
    ">>> powers = np.linspace(0, 10, 100)\n"
    ">>> orders = [1, 2, 3]\n"
    ">>> scales = [1, 2]\n"
    ">>> all_combinations = [(order, scale) for order in orders\n"
    "...                     for scale in scales]\n"
    ">>> for order, scale in all_combinations:\n"
    "...     ax.plot(powers, besselpoly(scale, powers, order),\n"
    "...             label=rf\"$\\nu={order}, a={scale}$\")\n"
    ">>> ax.legend()\n"
    ">>> ax.set_xlabel(r\"$\\lambda$\")\n"
    ">>> ax.set_ylabel(r\"$\\int_0^1 x^{\\lambda} J_{\\nu}(2ax)\\,dx$\")\n"
    ">>> plt.show()")
ufunc_besselpoly_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_besselpoly_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_besselpoly_types[0] = <char>NPY_FLOAT
ufunc_besselpoly_types[1] = <char>NPY_FLOAT
ufunc_besselpoly_types[2] = <char>NPY_FLOAT
ufunc_besselpoly_types[3] = <char>NPY_FLOAT
ufunc_besselpoly_types[4] = <char>NPY_DOUBLE
ufunc_besselpoly_types[5] = <char>NPY_DOUBLE
ufunc_besselpoly_types[6] = <char>NPY_DOUBLE
ufunc_besselpoly_types[7] = <char>NPY_DOUBLE
ufunc_besselpoly_ptr[2*0] = <void*>_func_cephes_besselpoly
ufunc_besselpoly_ptr[2*0+1] = <void*>(<char*>"besselpoly")
ufunc_besselpoly_ptr[2*1] = <void*>_func_cephes_besselpoly
ufunc_besselpoly_ptr[2*1+1] = <void*>(<char*>"besselpoly")
ufunc_besselpoly_data[0] = &ufunc_besselpoly_ptr[2*0]
ufunc_besselpoly_data[1] = &ufunc_besselpoly_ptr[2*1]
besselpoly = np.PyUFunc_FromFuncAndData(ufunc_besselpoly_loops, ufunc_besselpoly_data, ufunc_besselpoly_types, 2, 3, 1, 0, "besselpoly", ufunc_besselpoly_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_beta_loops[2]
cdef void *ufunc_beta_ptr[4]
cdef void *ufunc_beta_data[2]
cdef char ufunc_beta_types[6]
cdef char *ufunc_beta_doc = (
    "beta(a, b, out=None)\n"
    "\n"
    "Beta function.\n"
    "\n"
    "This function is defined in [1]_ as\n"
    "\n"
    ".. math::\n"
    "\n"
    "    B(a, b) = \\int_0^1 t^{a-1}(1-t)^{b-1}dt\n"
    "            = \\frac{\\Gamma(a)\\Gamma(b)}{\\Gamma(a+b)},\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Real-valued arguments\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function result\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gamma : the gamma function\n"
    "betainc :  the regularized incomplete beta function\n"
    "betaln : the natural logarithm of the absolute\n"
    "         value of the beta function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions,\n"
    "       Eq. 5.12.1. https://dlmf.nist.gov/5.12\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "The beta function relates to the gamma function by the\n"
    "definition given above:\n"
    "\n"
    ">>> sc.beta(2, 3)\n"
    "0.08333333333333333\n"
    ">>> sc.gamma(2)*sc.gamma(3)/sc.gamma(2 + 3)\n"
    "0.08333333333333333\n"
    "\n"
    "As this relationship demonstrates, the beta function\n"
    "is symmetric:\n"
    "\n"
    ">>> sc.beta(1.7, 2.4)\n"
    "0.16567527689031739\n"
    ">>> sc.beta(2.4, 1.7)\n"
    "0.16567527689031739\n"
    "\n"
    "This function satisfies :math:`B(1, b) = 1/b`:\n"
    "\n"
    ">>> sc.beta(1, 4)\n"
    "0.25")
ufunc_beta_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_beta_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_beta_types[0] = <char>NPY_FLOAT
ufunc_beta_types[1] = <char>NPY_FLOAT
ufunc_beta_types[2] = <char>NPY_FLOAT
ufunc_beta_types[3] = <char>NPY_DOUBLE
ufunc_beta_types[4] = <char>NPY_DOUBLE
ufunc_beta_types[5] = <char>NPY_DOUBLE
ufunc_beta_ptr[2*0] = <void*>_func_cephes_beta
ufunc_beta_ptr[2*0+1] = <void*>(<char*>"beta")
ufunc_beta_ptr[2*1] = <void*>_func_cephes_beta
ufunc_beta_ptr[2*1+1] = <void*>(<char*>"beta")
ufunc_beta_data[0] = &ufunc_beta_ptr[2*0]
ufunc_beta_data[1] = &ufunc_beta_ptr[2*1]
beta = np.PyUFunc_FromFuncAndData(ufunc_beta_loops, ufunc_beta_data, ufunc_beta_types, 2, 2, 1, 0, "beta", ufunc_beta_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betainc_loops[2]
cdef void *ufunc_betainc_ptr[4]
cdef void *ufunc_betainc_data[2]
cdef char ufunc_betainc_types[8]
cdef char *ufunc_betainc_doc = (
    "betainc(a, b, x, out=None)\n"
    "\n"
    "Regularized incomplete beta function.\n"
    "\n"
    "Computes the regularized incomplete beta function, defined as [1]_:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} \\int_0^x\n"
    "    t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "for :math:`0 \\leq x \\leq 1`.\n"
    "\n"
    "This function is the cumulative distribution function for the beta\n"
    "distribution; its range is [0, 1].\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "beta : beta function\n"
    "betaincinv : inverse of the regularized incomplete beta function\n"
    "betaincc : complement of the regularized incomplete beta function\n"
    "scipy.stats.beta : beta distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The term *regularized* in the name of this function refers to the\n"
    "scaling of the function by the gamma function terms shown in the\n"
    "formula.  When not qualified as *regularized*, the name *incomplete\n"
    "beta function* often refers to just the integral expression,\n"
    "without the gamma terms.  One can use the function `beta` from\n"
    "`scipy.special` to get this \"nonregularized\" incomplete beta\n"
    "function by multiplying the result of ``betainc(a, b, x)`` by\n"
    "``beta(a, b)``.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    "\n"
    "Let :math:`B(a, b)` be the `beta` function.\n"
    "\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "The coefficient in terms of `gamma` is equal to\n"
    ":math:`1/B(a, b)`. Also, when :math:`x=1`\n"
    "the integral is equal to :math:`B(a, b)`.\n"
    "Therefore, :math:`I_{x=1}(a, b) = 1` for any :math:`a, b`.\n"
    "\n"
    ">>> sc.betainc(0.2, 3.5, 1.0)\n"
    "1.0\n"
    "\n"
    "It satisfies\n"
    ":math:`I_x(a, b) = x^a F(a, 1-b, a+1, x)/ (aB(a, b))`,\n"
    "where :math:`F` is the hypergeometric function `hyp2f1`:\n"
    "\n"
    ">>> a, b, x = 1.4, 3.1, 0.5\n"
    ">>> x**a * sc.hyp2f1(a, 1 - b, a + 1, x)/(a * sc.beta(a, b))\n"
    "0.8148904036225295\n"
    ">>> sc.betainc(a, b, x)\n"
    "0.8148904036225296\n"
    "\n"
    "This functions satisfies the relationship\n"
    ":math:`I_x(a, b) = 1 - I_{1-x}(b, a)`:\n"
    "\n"
    ">>> sc.betainc(2.2, 3.1, 0.4)\n"
    "0.49339638807619446\n"
    ">>> 1 - sc.betainc(3.1, 2.2, 1 - 0.4)\n"
    "0.49339638807619446")
ufunc_betainc_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betainc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betainc_types[0] = <char>NPY_FLOAT
ufunc_betainc_types[1] = <char>NPY_FLOAT
ufunc_betainc_types[2] = <char>NPY_FLOAT
ufunc_betainc_types[3] = <char>NPY_FLOAT
ufunc_betainc_types[4] = <char>NPY_DOUBLE
ufunc_betainc_types[5] = <char>NPY_DOUBLE
ufunc_betainc_types[6] = <char>NPY_DOUBLE
ufunc_betainc_types[7] = <char>NPY_DOUBLE
ufunc_betainc_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibeta_float
ufunc_betainc_ptr[2*0+1] = <void*>(<char*>"betainc")
ufunc_betainc_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibeta_double
ufunc_betainc_ptr[2*1+1] = <void*>(<char*>"betainc")
ufunc_betainc_data[0] = &ufunc_betainc_ptr[2*0]
ufunc_betainc_data[1] = &ufunc_betainc_ptr[2*1]
betainc = np.PyUFunc_FromFuncAndData(ufunc_betainc_loops, ufunc_betainc_data, ufunc_betainc_types, 2, 3, 1, 0, "betainc", ufunc_betainc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaincc_loops[2]
cdef void *ufunc_betaincc_ptr[4]
cdef void *ufunc_betaincc_data[2]
cdef char ufunc_betaincc_types[8]
cdef char *ufunc_betaincc_doc = (
    "betaincc(a, b, x, out=None)\n"
    "\n"
    "Complement of the regularized incomplete beta function.\n"
    "\n"
    "Computes the complement of the regularized incomplete beta function,\n"
    "defined as [1]_:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\bar{I}_x(a, b) = 1 - I_x(a, b)\n"
    "                    = 1 - \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)} \\int_0^x\n"
    "                              t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "for :math:`0 \\leq x \\leq 1`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "       Positive, real-valued parameters\n"
    "x : array_like\n"
    "    Real-valued such that :math:`0 \\leq x \\leq 1`,\n"
    "    the upper limit of integration\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "betaincinv : inverse of the regularized incomplete beta function\n"
    "betainccinv :\n"
    "    inverse of the complement of the regularized incomplete beta function\n"
    "beta : beta function\n"
    "scipy.stats.beta : beta distribution\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 1.11.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import betaincc, betainc\n"
    "\n"
    "The naive calculation ``1 - betainc(a, b, x)`` loses precision when\n"
    "the values of ``betainc(a, b, x)`` are close to 1:\n"
    "\n"
    ">>> 1 - betainc(0.5, 8, [0.9, 0.99, 0.999])\n"
    "array([2.0574632e-09, 0.0000000e+00, 0.0000000e+00])\n"
    "\n"
    "By using ``betaincc``, we get the correct values:\n"
    "\n"
    ">>> betaincc(0.5, 8, [0.9, 0.99, 0.999])\n"
    "array([2.05746321e-09, 1.97259354e-17, 1.96467954e-25])")
ufunc_betaincc_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betaincc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betaincc_types[0] = <char>NPY_FLOAT
ufunc_betaincc_types[1] = <char>NPY_FLOAT
ufunc_betaincc_types[2] = <char>NPY_FLOAT
ufunc_betaincc_types[3] = <char>NPY_FLOAT
ufunc_betaincc_types[4] = <char>NPY_DOUBLE
ufunc_betaincc_types[5] = <char>NPY_DOUBLE
ufunc_betaincc_types[6] = <char>NPY_DOUBLE
ufunc_betaincc_types[7] = <char>NPY_DOUBLE
ufunc_betaincc_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibetac_float
ufunc_betaincc_ptr[2*0+1] = <void*>(<char*>"betaincc")
ufunc_betaincc_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibetac_double
ufunc_betaincc_ptr[2*1+1] = <void*>(<char*>"betaincc")
ufunc_betaincc_data[0] = &ufunc_betaincc_ptr[2*0]
ufunc_betaincc_data[1] = &ufunc_betaincc_ptr[2*1]
betaincc = np.PyUFunc_FromFuncAndData(ufunc_betaincc_loops, ufunc_betaincc_data, ufunc_betaincc_types, 2, 3, 1, 0, "betaincc", ufunc_betaincc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betainccinv_loops[2]
cdef void *ufunc_betainccinv_ptr[4]
cdef void *ufunc_betainccinv_data[2]
cdef char ufunc_betainccinv_types[8]
cdef char *ufunc_betainccinv_doc = (
    "betainccinv(a, b, y, out=None)\n"
    "\n"
    "Inverse of the complemented regularized incomplete beta function.\n"
    "\n"
    "Computes :math:`x` such that:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    y = 1 - I_x(a, b) = 1 - \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)}\n"
    "    \\int_0^x t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "where :math:`I_x` is the normalized incomplete beta function `betainc`\n"
    "and :math:`\\Gamma` is the `gamma` function [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Positive, real-valued parameters\n"
    "y : array_like\n"
    "    Real-valued input\n"
    "out : ndarray, optional\n"
    "    Optional output array for function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the inverse of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "betaincc : complement of the regularized incomplete beta function\n"
    "\n"
    "Notes\n"
    "-----\n"
    ".. versionadded:: 1.11.0\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import betainccinv, betaincc\n"
    "\n"
    "This function is the inverse of `betaincc` for fixed\n"
    "values of :math:`a` and :math:`b`.\n"
    "\n"
    ">>> a, b = 1.2, 3.1\n"
    ">>> y = betaincc(a, b, 0.2)\n"
    ">>> betainccinv(a, b, y)\n"
    "0.2\n"
    "\n"
    ">>> a, b = 7, 2.5\n"
    ">>> x = betainccinv(a, b, 0.875)\n"
    ">>> betaincc(a, b, x)\n"
    "0.875")
ufunc_betainccinv_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betainccinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betainccinv_types[0] = <char>NPY_FLOAT
ufunc_betainccinv_types[1] = <char>NPY_FLOAT
ufunc_betainccinv_types[2] = <char>NPY_FLOAT
ufunc_betainccinv_types[3] = <char>NPY_FLOAT
ufunc_betainccinv_types[4] = <char>NPY_DOUBLE
ufunc_betainccinv_types[5] = <char>NPY_DOUBLE
ufunc_betainccinv_types[6] = <char>NPY_DOUBLE
ufunc_betainccinv_types[7] = <char>NPY_DOUBLE
ufunc_betainccinv_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibetac_inv_float
ufunc_betainccinv_ptr[2*0+1] = <void*>(<char*>"betainccinv")
ufunc_betainccinv_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibetac_inv_double
ufunc_betainccinv_ptr[2*1+1] = <void*>(<char*>"betainccinv")
ufunc_betainccinv_data[0] = &ufunc_betainccinv_ptr[2*0]
ufunc_betainccinv_data[1] = &ufunc_betainccinv_ptr[2*1]
betainccinv = np.PyUFunc_FromFuncAndData(ufunc_betainccinv_loops, ufunc_betainccinv_data, ufunc_betainccinv_types, 2, 3, 1, 0, "betainccinv", ufunc_betainccinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaincinv_loops[2]
cdef void *ufunc_betaincinv_ptr[4]
cdef void *ufunc_betaincinv_data[2]
cdef char ufunc_betaincinv_types[8]
cdef char *ufunc_betaincinv_doc = (
    "betaincinv(a, b, y, out=None)\n"
    "\n"
    "Inverse of the regularized incomplete beta function.\n"
    "\n"
    "Computes :math:`x` such that:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    y = I_x(a, b) = \\frac{\\Gamma(a+b)}{\\Gamma(a)\\Gamma(b)}\n"
    "    \\int_0^x t^{a-1}(1-t)^{b-1}dt,\n"
    "\n"
    "where :math:`I_x` is the normalized incomplete beta function `betainc`\n"
    "and :math:`\\Gamma` is the `gamma` function [1]_.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Positive, real-valued parameters\n"
    "y : array_like\n"
    "    Real-valued input\n"
    "out : ndarray, optional\n"
    "    Optional output array for function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the inverse of the regularized incomplete beta function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc : regularized incomplete beta function\n"
    "gamma : gamma function\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] NIST Digital Library of Mathematical Functions\n"
    "       https://dlmf.nist.gov/8.17\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "This function is the inverse of `betainc` for fixed\n"
    "values of :math:`a` and :math:`b`.\n"
    "\n"
    ">>> a, b = 1.2, 3.1\n"
    ">>> y = sc.betainc(a, b, 0.2)\n"
    ">>> sc.betaincinv(a, b, y)\n"
    "0.2\n"
    ">>>\n"
    ">>> a, b = 7.5, 0.4\n"
    ">>> x = sc.betaincinv(a, b, 0.5)\n"
    ">>> sc.betainc(a, b, x)\n"
    "0.5")
ufunc_betaincinv_loops[0] = <np.PyUFuncGenericFunction>loop_f_fff__As_fff_f
ufunc_betaincinv_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_betaincinv_types[0] = <char>NPY_FLOAT
ufunc_betaincinv_types[1] = <char>NPY_FLOAT
ufunc_betaincinv_types[2] = <char>NPY_FLOAT
ufunc_betaincinv_types[3] = <char>NPY_FLOAT
ufunc_betaincinv_types[4] = <char>NPY_DOUBLE
ufunc_betaincinv_types[5] = <char>NPY_DOUBLE
ufunc_betaincinv_types[6] = <char>NPY_DOUBLE
ufunc_betaincinv_types[7] = <char>NPY_DOUBLE
ufunc_betaincinv_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_ibeta_inv_float
ufunc_betaincinv_ptr[2*0+1] = <void*>(<char*>"betaincinv")
ufunc_betaincinv_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_ibeta_inv_double
ufunc_betaincinv_ptr[2*1+1] = <void*>(<char*>"betaincinv")
ufunc_betaincinv_data[0] = &ufunc_betaincinv_ptr[2*0]
ufunc_betaincinv_data[1] = &ufunc_betaincinv_ptr[2*1]
betaincinv = np.PyUFunc_FromFuncAndData(ufunc_betaincinv_loops, ufunc_betaincinv_data, ufunc_betaincinv_types, 2, 3, 1, 0, "betaincinv", ufunc_betaincinv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_betaln_loops[2]
cdef void *ufunc_betaln_ptr[4]
cdef void *ufunc_betaln_data[2]
cdef char ufunc_betaln_types[6]
cdef char *ufunc_betaln_doc = (
    "betaln(a, b, out=None)\n"
    "\n"
    "Natural logarithm of absolute value of beta function.\n"
    "\n"
    "Computes ``ln(abs(beta(a, b)))``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a, b : array_like\n"
    "    Positive, real-valued parameters\n"
    "out : ndarray, optional\n"
    "    Optional output array for function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Value of the betaln function\n"
    "\n"
    "See Also\n"
    "--------\n"
    "gamma : the gamma function\n"
    "betainc :  the regularized incomplete beta function\n"
    "beta : the beta function\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy.special import betaln, beta\n"
    "\n"
    "Verify that, for moderate values of ``a`` and ``b``, ``betaln(a, b)``\n"
    "is the same as ``log(beta(a, b))``:\n"
    "\n"
    ">>> betaln(3, 4)\n"
    "-4.0943445622221\n"
    "\n"
    ">>> np.log(beta(3, 4))\n"
    "-4.0943445622221\n"
    "\n"
    "In the following ``beta(a, b)`` underflows to 0, so we can't compute\n"
    "the logarithm of the actual value.\n"
    "\n"
    ">>> a = 400\n"
    ">>> b = 900\n"
    ">>> beta(a, b)\n"
    "0.0\n"
    "\n"
    "We can compute the logarithm of ``beta(a, b)`` by using `betaln`:\n"
    "\n"
    ">>> betaln(a, b)\n"
    "-804.3069951764146")
ufunc_betaln_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_betaln_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_betaln_types[0] = <char>NPY_FLOAT
ufunc_betaln_types[1] = <char>NPY_FLOAT
ufunc_betaln_types[2] = <char>NPY_FLOAT
ufunc_betaln_types[3] = <char>NPY_DOUBLE
ufunc_betaln_types[4] = <char>NPY_DOUBLE
ufunc_betaln_types[5] = <char>NPY_DOUBLE
ufunc_betaln_ptr[2*0] = <void*>_func_cephes_lbeta
ufunc_betaln_ptr[2*0+1] = <void*>(<char*>"betaln")
ufunc_betaln_ptr[2*1] = <void*>_func_cephes_lbeta
ufunc_betaln_ptr[2*1+1] = <void*>(<char*>"betaln")
ufunc_betaln_data[0] = &ufunc_betaln_ptr[2*0]
ufunc_betaln_data[1] = &ufunc_betaln_ptr[2*1]
betaln = np.PyUFunc_FromFuncAndData(ufunc_betaln_loops, ufunc_betaln_data, ufunc_betaln_types, 2, 2, 1, 0, "betaln", ufunc_betaln_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_boxcox_loops[2]
cdef void *ufunc_boxcox_ptr[4]
cdef void *ufunc_boxcox_data[2]
cdef char ufunc_boxcox_types[6]
cdef char *ufunc_boxcox_doc = (
    "boxcox(x, lmbda, out=None)\n"
    "\n"
    "Compute the Box-Cox transformation.\n"
    "\n"
    "The Box-Cox transformation is::\n"
    "\n"
    "    y = (x**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(x)                  if lmbda == 0\n"
    "\n"
    "Returns `nan` if ``x < 0``.\n"
    "Returns `-inf` if ``x == 0`` and ``lmbda < 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.14.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox\n"
    ">>> boxcox([1, 4, 10], 2.5)\n"
    "array([   0.        ,   12.4       ,  126.09110641])\n"
    ">>> boxcox(2, [0, 1, 2])\n"
    "array([ 0.69314718,  1.        ,  1.5       ])")
ufunc_boxcox_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_boxcox_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_boxcox_types[0] = <char>NPY_FLOAT
ufunc_boxcox_types[1] = <char>NPY_FLOAT
ufunc_boxcox_types[2] = <char>NPY_FLOAT
ufunc_boxcox_types[3] = <char>NPY_DOUBLE
ufunc_boxcox_types[4] = <char>NPY_DOUBLE
ufunc_boxcox_types[5] = <char>NPY_DOUBLE
ufunc_boxcox_ptr[2*0] = <void*>_func_boxcox
ufunc_boxcox_ptr[2*0+1] = <void*>(<char*>"boxcox")
ufunc_boxcox_ptr[2*1] = <void*>_func_boxcox
ufunc_boxcox_ptr[2*1+1] = <void*>(<char*>"boxcox")
ufunc_boxcox_data[0] = &ufunc_boxcox_ptr[2*0]
ufunc_boxcox_data[1] = &ufunc_boxcox_ptr[2*1]
boxcox = np.PyUFunc_FromFuncAndData(ufunc_boxcox_loops, ufunc_boxcox_data, ufunc_boxcox_types, 2, 2, 1, 0, "boxcox", ufunc_boxcox_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_boxcox1p_loops[2]
cdef void *ufunc_boxcox1p_ptr[4]
cdef void *ufunc_boxcox1p_data[2]
cdef char ufunc_boxcox1p_types[6]
cdef char *ufunc_boxcox1p_doc = (
    "boxcox1p(x, lmbda, out=None)\n"
    "\n"
    "Compute the Box-Cox transformation of 1 + `x`.\n"
    "\n"
    "The Box-Cox transformation computed by `boxcox1p` is::\n"
    "\n"
    "    y = ((1+x)**lmbda - 1) / lmbda  if lmbda != 0\n"
    "        log(1+x)                    if lmbda == 0\n"
    "\n"
    "Returns `nan` if ``x < -1``.\n"
    "Returns `-inf` if ``x == -1`` and ``lmbda < 0``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Data to be transformed.\n"
    "lmbda : array_like\n"
    "    Power parameter of the Box-Cox transform.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Transformed data.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "\n"
    ".. versionadded:: 0.14.0\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import boxcox1p\n"
    ">>> boxcox1p(1e-4, [0, 0.5, 1])\n"
    "array([  9.99950003e-05,   9.99975001e-05,   1.00000000e-04])\n"
    ">>> boxcox1p([0.01, 0.1], 0.25)\n"
    "array([ 0.00996272,  0.09645476])")
ufunc_boxcox1p_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_boxcox1p_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_boxcox1p_types[0] = <char>NPY_FLOAT
ufunc_boxcox1p_types[1] = <char>NPY_FLOAT
ufunc_boxcox1p_types[2] = <char>NPY_FLOAT
ufunc_boxcox1p_types[3] = <char>NPY_DOUBLE
ufunc_boxcox1p_types[4] = <char>NPY_DOUBLE
ufunc_boxcox1p_types[5] = <char>NPY_DOUBLE
ufunc_boxcox1p_ptr[2*0] = <void*>_func_boxcox1p
ufunc_boxcox1p_ptr[2*0+1] = <void*>(<char*>"boxcox1p")
ufunc_boxcox1p_ptr[2*1] = <void*>_func_boxcox1p
ufunc_boxcox1p_ptr[2*1+1] = <void*>(<char*>"boxcox1p")
ufunc_boxcox1p_data[0] = &ufunc_boxcox1p_ptr[2*0]
ufunc_boxcox1p_data[1] = &ufunc_boxcox1p_ptr[2*1]
boxcox1p = np.PyUFunc_FromFuncAndData(ufunc_boxcox1p_loops, ufunc_boxcox1p_data, ufunc_boxcox1p_types, 2, 2, 1, 0, "boxcox1p", ufunc_boxcox1p_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtr_loops[2]
cdef void *ufunc_btdtr_ptr[4]
cdef void *ufunc_btdtr_data[2]
cdef char ufunc_btdtr_types[8]
cdef char *ufunc_btdtr_doc = (
    "btdtr(a, b, x, out=None)\n"
    "\n"
    "Cumulative distribution function of the beta distribution.\n"
    "\n"
    "Returns the integral from zero to `x` of the beta probability density\n"
    "function,\n"
    "\n"
    ".. math::\n"
    "    I = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "where :math:`\\Gamma` is the gamma function.\n"
    "\n"
    ".. deprecated:: 1.12.0\n"
    "    This function is deprecated and will be removed from SciPy 1.14.0.\n"
    "    Use `scipy.special.betainc` instead.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (a > 0).\n"
    "b : array_like\n"
    "    Shape parameter (b > 0).\n"
    "x : array_like\n"
    "    Upper limit of integration, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "I : scalar or ndarray\n"
    "    Cumulative distribution function of the beta distribution with\n"
    "    parameters `a` and `b` at `x`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betainc\n"
    "\n"
    "Notes\n"
    "-----\n"
    "This function is identical to the incomplete beta integral function\n"
    "`betainc`.\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `btdtr`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_btdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtr_types[0] = <char>NPY_FLOAT
ufunc_btdtr_types[1] = <char>NPY_FLOAT
ufunc_btdtr_types[2] = <char>NPY_FLOAT
ufunc_btdtr_types[3] = <char>NPY_FLOAT
ufunc_btdtr_types[4] = <char>NPY_DOUBLE
ufunc_btdtr_types[5] = <char>NPY_DOUBLE
ufunc_btdtr_types[6] = <char>NPY_DOUBLE
ufunc_btdtr_types[7] = <char>NPY_DOUBLE
ufunc_btdtr_ptr[2*0] = <void*>_func_cephes_btdtr
ufunc_btdtr_ptr[2*0+1] = <void*>(<char*>"btdtr")
ufunc_btdtr_ptr[2*1] = <void*>_func_cephes_btdtr
ufunc_btdtr_ptr[2*1+1] = <void*>(<char*>"btdtr")
ufunc_btdtr_data[0] = &ufunc_btdtr_ptr[2*0]
ufunc_btdtr_data[1] = &ufunc_btdtr_ptr[2*1]
btdtr = np.PyUFunc_FromFuncAndData(ufunc_btdtr_loops, ufunc_btdtr_data, ufunc_btdtr_types, 2, 3, 1, 0, "btdtr", ufunc_btdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtri_loops[2]
cdef void *ufunc_btdtri_ptr[4]
cdef void *ufunc_btdtri_data[2]
cdef char ufunc_btdtri_types[8]
cdef char *ufunc_btdtri_doc = (
    "btdtri(a, b, p, out=None)\n"
    "\n"
    "The `p`-th quantile of the beta distribution.\n"
    "\n"
    "This function is the inverse of the beta cumulative distribution function,\n"
    "`btdtr`, returning the value of `x` for which `btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    ".. deprecated:: 1.12.0\n"
    "    This function is deprecated and will be removed from SciPy 1.14.0.\n"
    "    Use `scipy.special.betaincinv` instead.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (`a` > 0).\n"
    "b : array_like\n"
    "    Shape parameter (`b` > 0).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    The quantile corresponding to `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "betaincinv\n"
    "btdtr\n"
    "\n"
    "Notes\n"
    "-----\n"
    "The value of `x` is found by interval halving or Newton iterations.\n"
    "\n"
    "Wrapper for the Cephes [1]_ routine `incbi`, which solves the equivalent\n"
    "problem of finding the inverse of the incomplete beta integral.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Cephes Mathematical Functions Library,\n"
    "       http://www.netlib.org/cephes/")
ufunc_btdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtri_types[0] = <char>NPY_FLOAT
ufunc_btdtri_types[1] = <char>NPY_FLOAT
ufunc_btdtri_types[2] = <char>NPY_FLOAT
ufunc_btdtri_types[3] = <char>NPY_FLOAT
ufunc_btdtri_types[4] = <char>NPY_DOUBLE
ufunc_btdtri_types[5] = <char>NPY_DOUBLE
ufunc_btdtri_types[6] = <char>NPY_DOUBLE
ufunc_btdtri_types[7] = <char>NPY_DOUBLE
ufunc_btdtri_ptr[2*0] = <void*>_func_cephes_btdtri
ufunc_btdtri_ptr[2*0+1] = <void*>(<char*>"btdtri")
ufunc_btdtri_ptr[2*1] = <void*>_func_cephes_btdtri
ufunc_btdtri_ptr[2*1+1] = <void*>(<char*>"btdtri")
ufunc_btdtri_data[0] = &ufunc_btdtri_ptr[2*0]
ufunc_btdtri_data[1] = &ufunc_btdtri_ptr[2*1]
btdtri = np.PyUFunc_FromFuncAndData(ufunc_btdtri_loops, ufunc_btdtri_data, ufunc_btdtri_types, 2, 3, 1, 0, "btdtri", ufunc_btdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtria_loops[2]
cdef void *ufunc_btdtria_ptr[4]
cdef void *ufunc_btdtria_data[2]
cdef char ufunc_btdtria_types[8]
cdef char *ufunc_btdtria_doc = (
    "btdtria(p, b, x, out=None)\n"
    "\n"
    "Inverse of `btdtr` with respect to `a`.\n"
    "\n"
    "This is the inverse of the beta cumulative distribution function, `btdtr`,\n"
    "considered as a function of `a`, returning the value of `a` for which\n"
    "`btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "b : array_like\n"
    "    Shape parameter (`b` > 0).\n"
    "x : array_like\n"
    "    The quantile, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "a : scalar or ndarray\n"
    "    The value of the shape parameter `a` such that `btdtr(a, b, x) = p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "btdtr : Cumulative distribution function of the beta distribution.\n"
    "btdtri : Inverse with respect to `x`.\n"
    "btdtrib : Inverse with respect to `b`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `a` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `a`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n"
    "       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.")
ufunc_btdtria_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtria_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtria_types[0] = <char>NPY_FLOAT
ufunc_btdtria_types[1] = <char>NPY_FLOAT
ufunc_btdtria_types[2] = <char>NPY_FLOAT
ufunc_btdtria_types[3] = <char>NPY_FLOAT
ufunc_btdtria_types[4] = <char>NPY_DOUBLE
ufunc_btdtria_types[5] = <char>NPY_DOUBLE
ufunc_btdtria_types[6] = <char>NPY_DOUBLE
ufunc_btdtria_types[7] = <char>NPY_DOUBLE
ufunc_btdtria_ptr[2*0] = <void*>_func_btdtria
ufunc_btdtria_ptr[2*0+1] = <void*>(<char*>"btdtria")
ufunc_btdtria_ptr[2*1] = <void*>_func_btdtria
ufunc_btdtria_ptr[2*1+1] = <void*>(<char*>"btdtria")
ufunc_btdtria_data[0] = &ufunc_btdtria_ptr[2*0]
ufunc_btdtria_data[1] = &ufunc_btdtria_ptr[2*1]
btdtria = np.PyUFunc_FromFuncAndData(ufunc_btdtria_loops, ufunc_btdtria_data, ufunc_btdtria_types, 2, 3, 1, 0, "btdtria", ufunc_btdtria_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_btdtrib_loops[2]
cdef void *ufunc_btdtrib_ptr[4]
cdef void *ufunc_btdtrib_data[2]
cdef char ufunc_btdtrib_types[8]
cdef char *ufunc_btdtrib_doc = (
    "btdtria(a, p, x, out=None)\n"
    "\n"
    "Inverse of `btdtr` with respect to `b`.\n"
    "\n"
    "This is the inverse of the beta cumulative distribution function, `btdtr`,\n"
    "considered as a function of `b`, returning the value of `b` for which\n"
    "`btdtr(a, b, x) = p`, or\n"
    "\n"
    ".. math::\n"
    "    p = \\int_0^x \\frac{\\Gamma(a + b)}{\\Gamma(a)\\Gamma(b)} t^{a-1} (1-t)^{b-1}\\,dt\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "a : array_like\n"
    "    Shape parameter (`a` > 0).\n"
    "p : array_like\n"
    "    Cumulative probability, in [0, 1].\n"
    "x : array_like\n"
    "    The quantile, in [0, 1].\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "b : scalar or ndarray\n"
    "    The value of the shape parameter `b` such that `btdtr(a, b, x) = p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "btdtr : Cumulative distribution function of the beta distribution.\n"
    "btdtri : Inverse with respect to `x`.\n"
    "btdtria : Inverse with respect to `a`.\n"
    "\n"
    "Notes\n"
    "-----\n"
    "Wrapper for the CDFLIB [1]_ Fortran routine `cdfbet`.\n"
    "\n"
    "The cumulative distribution function `p` is computed using a routine by\n"
    "DiDinato and Morris [2]_. Computation of `b` involves a search for a value\n"
    "that produces the desired value of `p`. The search relies on the\n"
    "monotonicity of `p` with `b`.\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Barry Brown, James Lovato, and Kathy Russell,\n"
    "       CDFLIB: Library of Fortran Routines for Cumulative Distribution\n"
    "       Functions, Inverses, and Other Parameters.\n"
    ".. [2] DiDinato, A. R. and Morris, A. H.,\n"
    "       Algorithm 708: Significant Digit Computation of the Incomplete Beta\n"
    "       Function Ratios. ACM Trans. Math. Softw. 18 (1993), 360-373.")
ufunc_btdtrib_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_btdtrib_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_btdtrib_types[0] = <char>NPY_FLOAT
ufunc_btdtrib_types[1] = <char>NPY_FLOAT
ufunc_btdtrib_types[2] = <char>NPY_FLOAT
ufunc_btdtrib_types[3] = <char>NPY_FLOAT
ufunc_btdtrib_types[4] = <char>NPY_DOUBLE
ufunc_btdtrib_types[5] = <char>NPY_DOUBLE
ufunc_btdtrib_types[6] = <char>NPY_DOUBLE
ufunc_btdtrib_types[7] = <char>NPY_DOUBLE
ufunc_btdtrib_ptr[2*0] = <void*>_func_btdtrib
ufunc_btdtrib_ptr[2*0+1] = <void*>(<char*>"btdtrib")
ufunc_btdtrib_ptr[2*1] = <void*>_func_btdtrib
ufunc_btdtrib_ptr[2*1+1] = <void*>(<char*>"btdtrib")
ufunc_btdtrib_data[0] = &ufunc_btdtrib_ptr[2*0]
ufunc_btdtrib_data[1] = &ufunc_btdtrib_ptr[2*1]
btdtrib = np.PyUFunc_FromFuncAndData(ufunc_btdtrib_loops, ufunc_btdtrib_data, ufunc_btdtrib_types, 2, 3, 1, 0, "btdtrib", ufunc_btdtrib_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cbrt_loops[2]
cdef void *ufunc_cbrt_ptr[4]
cdef void *ufunc_cbrt_data[2]
cdef char ufunc_cbrt_types[4]
cdef char *ufunc_cbrt_doc = (
    "cbrt(x, out=None)\n"
    "\n"
    "Element-wise cube root of `x`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    `x` must contain real numbers.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    The cube root of each value in `x`.\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> from scipy.special import cbrt\n"
    "\n"
    ">>> cbrt(8)\n"
    "2.0\n"
    ">>> cbrt([-8, -3, 0.125, 1.331])\n"
    "array([-2.        , -1.44224957,  0.5       ,  1.1       ])")
ufunc_cbrt_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cbrt_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cbrt_types[0] = <char>NPY_FLOAT
ufunc_cbrt_types[1] = <char>NPY_FLOAT
ufunc_cbrt_types[2] = <char>NPY_DOUBLE
ufunc_cbrt_types[3] = <char>NPY_DOUBLE
ufunc_cbrt_ptr[2*0] = <void*>_func_cephes_cbrt
ufunc_cbrt_ptr[2*0+1] = <void*>(<char*>"cbrt")
ufunc_cbrt_ptr[2*1] = <void*>_func_cephes_cbrt
ufunc_cbrt_ptr[2*1+1] = <void*>(<char*>"cbrt")
ufunc_cbrt_data[0] = &ufunc_cbrt_ptr[2*0]
ufunc_cbrt_data[1] = &ufunc_cbrt_ptr[2*1]
cbrt = np.PyUFunc_FromFuncAndData(ufunc_cbrt_loops, ufunc_cbrt_data, ufunc_cbrt_types, 2, 1, 1, 0, "cbrt", ufunc_cbrt_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtr_loops[2]
cdef void *ufunc_chdtr_ptr[4]
cdef void *ufunc_chdtr_data[2]
cdef char ufunc_chdtr_types[6]
cdef char *ufunc_chdtr_doc = (
    "chdtr(v, x, out=None)\n"
    "\n"
    "Chi square cumulative distribution function.\n"
    "\n"
    "Returns the area under the left tail (from 0 to `x`) of the Chi\n"
    "square probability density function with `v` degrees of freedom:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_0^x t^{v/2 - 1} e^{-t/2} dt\n"
    "\n"
    "Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n"
    "integral can be expressed in terms of the regularized lower\n"
    "incomplete gamma function `gammainc` as\n"
    "``gammainc(v / 2, x / 2)``. [1]_\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "x : array_like\n"
    "    Upper bound of the integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the cumulative distribution function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtrc, chdtri, chdtriv, gammainc\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It can be expressed in terms of the regularized lower incomplete\n"
    "gamma function.\n"
    "\n"
    ">>> v = 1\n"
    ">>> x = np.arange(4)\n"
    ">>> sc.chdtr(v, x)\n"
    "array([0.        , 0.68268949, 0.84270079, 0.91673548])\n"
    ">>> sc.gammainc(v / 2, x / 2)\n"
    "array([0.        , 0.68268949, 0.84270079, 0.91673548])")
ufunc_chdtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtr_types[0] = <char>NPY_FLOAT
ufunc_chdtr_types[1] = <char>NPY_FLOAT
ufunc_chdtr_types[2] = <char>NPY_FLOAT
ufunc_chdtr_types[3] = <char>NPY_DOUBLE
ufunc_chdtr_types[4] = <char>NPY_DOUBLE
ufunc_chdtr_types[5] = <char>NPY_DOUBLE
ufunc_chdtr_ptr[2*0] = <void*>_func_cephes_chdtr
ufunc_chdtr_ptr[2*0+1] = <void*>(<char*>"chdtr")
ufunc_chdtr_ptr[2*1] = <void*>_func_cephes_chdtr
ufunc_chdtr_ptr[2*1+1] = <void*>(<char*>"chdtr")
ufunc_chdtr_data[0] = &ufunc_chdtr_ptr[2*0]
ufunc_chdtr_data[1] = &ufunc_chdtr_ptr[2*1]
chdtr = np.PyUFunc_FromFuncAndData(ufunc_chdtr_loops, ufunc_chdtr_data, ufunc_chdtr_types, 2, 2, 1, 0, "chdtr", ufunc_chdtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtrc_loops[2]
cdef void *ufunc_chdtrc_ptr[4]
cdef void *ufunc_chdtrc_data[2]
cdef char ufunc_chdtrc_types[6]
cdef char *ufunc_chdtrc_doc = (
    "chdtrc(v, x, out=None)\n"
    "\n"
    "Chi square survival function.\n"
    "\n"
    "Returns the area under the right hand tail (from `x` to infinity)\n"
    "of the Chi square probability density function with `v` degrees of\n"
    "freedom:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    \\frac{1}{2^{v/2} \\Gamma(v/2)} \\int_x^\\infty t^{v/2 - 1} e^{-t/2} dt\n"
    "\n"
    "Here :math:`\\Gamma` is the Gamma function; see `gamma`. This\n"
    "integral can be expressed in terms of the regularized upper\n"
    "incomplete gamma function `gammaincc` as\n"
    "``gammaincc(v / 2, x / 2)``. [1]_\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "x : array_like\n"
    "    Lower bound of the integral.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of the survival function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtr, chdtri, chdtriv, gammaincc\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It can be expressed in terms of the regularized upper incomplete\n"
    "gamma function.\n"
    "\n"
    ">>> v = 1\n"
    ">>> x = np.arange(4)\n"
    ">>> sc.chdtrc(v, x)\n"
    "array([1.        , 0.31731051, 0.15729921, 0.08326452])\n"
    ">>> sc.gammaincc(v / 2, x / 2)\n"
    "array([1.        , 0.31731051, 0.15729921, 0.08326452])")
ufunc_chdtrc_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtrc_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtrc_types[0] = <char>NPY_FLOAT
ufunc_chdtrc_types[1] = <char>NPY_FLOAT
ufunc_chdtrc_types[2] = <char>NPY_FLOAT
ufunc_chdtrc_types[3] = <char>NPY_DOUBLE
ufunc_chdtrc_types[4] = <char>NPY_DOUBLE
ufunc_chdtrc_types[5] = <char>NPY_DOUBLE
ufunc_chdtrc_ptr[2*0] = <void*>_func_cephes_chdtrc
ufunc_chdtrc_ptr[2*0+1] = <void*>(<char*>"chdtrc")
ufunc_chdtrc_ptr[2*1] = <void*>_func_cephes_chdtrc
ufunc_chdtrc_ptr[2*1+1] = <void*>(<char*>"chdtrc")
ufunc_chdtrc_data[0] = &ufunc_chdtrc_ptr[2*0]
ufunc_chdtrc_data[1] = &ufunc_chdtrc_ptr[2*1]
chdtrc = np.PyUFunc_FromFuncAndData(ufunc_chdtrc_loops, ufunc_chdtrc_data, ufunc_chdtrc_types, 2, 2, 1, 0, "chdtrc", ufunc_chdtrc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtri_loops[2]
cdef void *ufunc_chdtri_ptr[4]
cdef void *ufunc_chdtri_data[2]
cdef char ufunc_chdtri_types[6]
cdef char *ufunc_chdtri_doc = (
    "chdtri(v, p, out=None)\n"
    "\n"
    "Inverse to `chdtrc` with respect to `x`.\n"
    "\n"
    "Returns `x` such that ``chdtrc(v, x) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "v : array_like\n"
    "    Degrees of freedom.\n"
    "p : array_like\n"
    "    Probability.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value so that the probability a Chi square random variable\n"
    "    with `v` degrees of freedom is greater than `x` equals `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtrc, chdtr, chdtriv\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It inverts `chdtrc`.\n"
    "\n"
    ">>> v, p = 1, 0.3\n"
    ">>> sc.chdtrc(v, sc.chdtri(v, p))\n"
    "0.3\n"
    ">>> x = 1\n"
    ">>> sc.chdtri(v, sc.chdtrc(v, x))\n"
    "1.0")
ufunc_chdtri_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtri_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtri_types[0] = <char>NPY_FLOAT
ufunc_chdtri_types[1] = <char>NPY_FLOAT
ufunc_chdtri_types[2] = <char>NPY_FLOAT
ufunc_chdtri_types[3] = <char>NPY_DOUBLE
ufunc_chdtri_types[4] = <char>NPY_DOUBLE
ufunc_chdtri_types[5] = <char>NPY_DOUBLE
ufunc_chdtri_ptr[2*0] = <void*>_func_cephes_chdtri
ufunc_chdtri_ptr[2*0+1] = <void*>(<char*>"chdtri")
ufunc_chdtri_ptr[2*1] = <void*>_func_cephes_chdtri
ufunc_chdtri_ptr[2*1+1] = <void*>(<char*>"chdtri")
ufunc_chdtri_data[0] = &ufunc_chdtri_ptr[2*0]
ufunc_chdtri_data[1] = &ufunc_chdtri_ptr[2*1]
chdtri = np.PyUFunc_FromFuncAndData(ufunc_chdtri_loops, ufunc_chdtri_data, ufunc_chdtri_types, 2, 2, 1, 0, "chdtri", ufunc_chdtri_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chdtriv_loops[2]
cdef void *ufunc_chdtriv_ptr[4]
cdef void *ufunc_chdtriv_data[2]
cdef char ufunc_chdtriv_types[6]
cdef char *ufunc_chdtriv_doc = (
    "chdtriv(p, x, out=None)\n"
    "\n"
    "Inverse to `chdtr` with respect to `v`.\n"
    "\n"
    "Returns `v` such that ``chdtr(v, x) == p``.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability that the Chi square random variable is less than\n"
    "    or equal to `x`.\n"
    "x : array_like\n"
    "    Nonnegative input.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Degrees of freedom.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chdtr, chdtrc, chdtri\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Chi-Square distribution,\n"
    "    https://www.itl.nist.gov/div898/handbook/eda/section3/eda3666.htm\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It inverts `chdtr`.\n"
    "\n"
    ">>> p, x = 0.5, 1\n"
    ">>> sc.chdtr(sc.chdtriv(p, x), x)\n"
    "0.5000000000202172\n"
    ">>> v = 1\n"
    ">>> sc.chdtriv(sc.chdtr(v, x), v)\n"
    "1.0000000000000013")
ufunc_chdtriv_loops[0] = <np.PyUFuncGenericFunction>loop_d_dd__As_ff_f
ufunc_chdtriv_loops[1] = <np.PyUFuncGenericFunction>loop_d_dd__As_dd_d
ufunc_chdtriv_types[0] = <char>NPY_FLOAT
ufunc_chdtriv_types[1] = <char>NPY_FLOAT
ufunc_chdtriv_types[2] = <char>NPY_FLOAT
ufunc_chdtriv_types[3] = <char>NPY_DOUBLE
ufunc_chdtriv_types[4] = <char>NPY_DOUBLE
ufunc_chdtriv_types[5] = <char>NPY_DOUBLE
ufunc_chdtriv_ptr[2*0] = <void*>_func_chdtriv
ufunc_chdtriv_ptr[2*0+1] = <void*>(<char*>"chdtriv")
ufunc_chdtriv_ptr[2*1] = <void*>_func_chdtriv
ufunc_chdtriv_ptr[2*1+1] = <void*>(<char*>"chdtriv")
ufunc_chdtriv_data[0] = &ufunc_chdtriv_ptr[2*0]
ufunc_chdtriv_data[1] = &ufunc_chdtriv_ptr[2*1]
chdtriv = np.PyUFunc_FromFuncAndData(ufunc_chdtriv_loops, ufunc_chdtriv_data, ufunc_chdtriv_types, 2, 2, 1, 0, "chdtriv", ufunc_chdtriv_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtr_loops[2]
cdef void *ufunc_chndtr_ptr[4]
cdef void *ufunc_chndtr_data[2]
cdef char ufunc_chndtr_types[8]
cdef char *ufunc_chndtr_doc = (
    "chndtr(x, df, nc, out=None)\n"
    "\n"
    "Non-central chi square cumulative distribution function\n"
    "\n"
    "The cumulative distribution function is given by:\n"
    "\n"
    ".. math::\n"
    "\n"
    "    P(\\chi^{\\prime 2} \\vert \\nu, \\lambda) =\\sum_{j=0}^{\\infty}\n"
    "    e^{-\\lambda /2}\n"
    "    \\frac{(\\lambda /2)^j}{j!} P(\\chi^{\\prime 2} \\vert \\nu + 2j),\n"
    "\n"
    "where :math:`\\nu > 0` is the degrees of freedom (``df``) and\n"
    ":math:`\\lambda \\geq 0` is the non-centrality parameter (``nc``).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value of the non-central chi square cumulative distribution function.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtrix, chndtridf, chndtrinc")
ufunc_chndtr_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtr_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtr_types[0] = <char>NPY_FLOAT
ufunc_chndtr_types[1] = <char>NPY_FLOAT
ufunc_chndtr_types[2] = <char>NPY_FLOAT
ufunc_chndtr_types[3] = <char>NPY_FLOAT
ufunc_chndtr_types[4] = <char>NPY_DOUBLE
ufunc_chndtr_types[5] = <char>NPY_DOUBLE
ufunc_chndtr_types[6] = <char>NPY_DOUBLE
ufunc_chndtr_types[7] = <char>NPY_DOUBLE
ufunc_chndtr_ptr[2*0] = <void*>_func_chndtr
ufunc_chndtr_ptr[2*0+1] = <void*>(<char*>"chndtr")
ufunc_chndtr_ptr[2*1] = <void*>_func_chndtr
ufunc_chndtr_ptr[2*1+1] = <void*>(<char*>"chndtr")
ufunc_chndtr_data[0] = &ufunc_chndtr_ptr[2*0]
ufunc_chndtr_data[1] = &ufunc_chndtr_ptr[2*1]
chndtr = np.PyUFunc_FromFuncAndData(ufunc_chndtr_loops, ufunc_chndtr_data, ufunc_chndtr_types, 2, 3, 1, 0, "chndtr", ufunc_chndtr_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtridf_loops[2]
cdef void *ufunc_chndtridf_ptr[4]
cdef void *ufunc_chndtridf_data[2]
cdef char ufunc_chndtridf_types[8]
cdef char *ufunc_chndtridf_doc = (
    "chndtridf(x, p, nc, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `df`\n"
    "\n"
    "Calculated using a search to find a value for `df` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "df : scalar or ndarray\n"
    "    Degrees of freedom\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtrix, chndtrinc")
ufunc_chndtridf_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtridf_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtridf_types[0] = <char>NPY_FLOAT
ufunc_chndtridf_types[1] = <char>NPY_FLOAT
ufunc_chndtridf_types[2] = <char>NPY_FLOAT
ufunc_chndtridf_types[3] = <char>NPY_FLOAT
ufunc_chndtridf_types[4] = <char>NPY_DOUBLE
ufunc_chndtridf_types[5] = <char>NPY_DOUBLE
ufunc_chndtridf_types[6] = <char>NPY_DOUBLE
ufunc_chndtridf_types[7] = <char>NPY_DOUBLE
ufunc_chndtridf_ptr[2*0] = <void*>_func_chndtridf
ufunc_chndtridf_ptr[2*0+1] = <void*>(<char*>"chndtridf")
ufunc_chndtridf_ptr[2*1] = <void*>_func_chndtridf
ufunc_chndtridf_ptr[2*1+1] = <void*>(<char*>"chndtridf")
ufunc_chndtridf_data[0] = &ufunc_chndtridf_ptr[2*0]
ufunc_chndtridf_data[1] = &ufunc_chndtridf_ptr[2*1]
chndtridf = np.PyUFunc_FromFuncAndData(ufunc_chndtridf_loops, ufunc_chndtridf_data, ufunc_chndtridf_types, 2, 3, 1, 0, "chndtridf", ufunc_chndtridf_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtrinc_loops[2]
cdef void *ufunc_chndtrinc_ptr[4]
cdef void *ufunc_chndtrinc_data[2]
cdef char ufunc_chndtrinc_types[8]
cdef char *ufunc_chndtrinc_doc = (
    "chndtrinc(x, df, p, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `nc`\n"
    "\n"
    "Calculated using a search to find a value for `df` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Upper bound of the integral; must satisfy ``x >= 0``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "nc : scalar or ndarray\n"
    "    Non-centrality\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtrix, chndtrinc")
ufunc_chndtrinc_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtrinc_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtrinc_types[0] = <char>NPY_FLOAT
ufunc_chndtrinc_types[1] = <char>NPY_FLOAT
ufunc_chndtrinc_types[2] = <char>NPY_FLOAT
ufunc_chndtrinc_types[3] = <char>NPY_FLOAT
ufunc_chndtrinc_types[4] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[5] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[6] = <char>NPY_DOUBLE
ufunc_chndtrinc_types[7] = <char>NPY_DOUBLE
ufunc_chndtrinc_ptr[2*0] = <void*>_func_chndtrinc
ufunc_chndtrinc_ptr[2*0+1] = <void*>(<char*>"chndtrinc")
ufunc_chndtrinc_ptr[2*1] = <void*>_func_chndtrinc
ufunc_chndtrinc_ptr[2*1+1] = <void*>(<char*>"chndtrinc")
ufunc_chndtrinc_data[0] = &ufunc_chndtrinc_ptr[2*0]
ufunc_chndtrinc_data[1] = &ufunc_chndtrinc_ptr[2*1]
chndtrinc = np.PyUFunc_FromFuncAndData(ufunc_chndtrinc_loops, ufunc_chndtrinc_data, ufunc_chndtrinc_types, 2, 3, 1, 0, "chndtrinc", ufunc_chndtrinc_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_chndtrix_loops[2]
cdef void *ufunc_chndtrix_ptr[4]
cdef void *ufunc_chndtrix_data[2]
cdef char ufunc_chndtrix_types[8]
cdef char *ufunc_chndtrix_doc = (
    "chndtrix(p, df, nc, out=None)\n"
    "\n"
    "Inverse to `chndtr` vs `x`\n"
    "\n"
    "Calculated using a search to find a value for `x` that produces the\n"
    "desired value of `p`.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "p : array_like\n"
    "    Probability; must satisfy ``0 <= p < 1``\n"
    "df : array_like\n"
    "    Degrees of freedom; must satisfy ``df > 0``\n"
    "nc : array_like\n"
    "    Non-centrality parameter; must satisfy ``nc >= 0``\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results\n"
    "\n"
    "Returns\n"
    "-------\n"
    "x : scalar or ndarray\n"
    "    Value so that the probability a non-central Chi square random variable\n"
    "    with `df` degrees of freedom and non-centrality, `nc`, is greater than\n"
    "    `x` equals `p`.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "chndtr, chndtridf, chndtrinc")
ufunc_chndtrix_loops[0] = <np.PyUFuncGenericFunction>loop_d_ddd__As_fff_f
ufunc_chndtrix_loops[1] = <np.PyUFuncGenericFunction>loop_d_ddd__As_ddd_d
ufunc_chndtrix_types[0] = <char>NPY_FLOAT
ufunc_chndtrix_types[1] = <char>NPY_FLOAT
ufunc_chndtrix_types[2] = <char>NPY_FLOAT
ufunc_chndtrix_types[3] = <char>NPY_FLOAT
ufunc_chndtrix_types[4] = <char>NPY_DOUBLE
ufunc_chndtrix_types[5] = <char>NPY_DOUBLE
ufunc_chndtrix_types[6] = <char>NPY_DOUBLE
ufunc_chndtrix_types[7] = <char>NPY_DOUBLE
ufunc_chndtrix_ptr[2*0] = <void*>_func_chndtrix
ufunc_chndtrix_ptr[2*0+1] = <void*>(<char*>"chndtrix")
ufunc_chndtrix_ptr[2*1] = <void*>_func_chndtrix
ufunc_chndtrix_ptr[2*1+1] = <void*>(<char*>"chndtrix")
ufunc_chndtrix_data[0] = &ufunc_chndtrix_ptr[2*0]
ufunc_chndtrix_data[1] = &ufunc_chndtrix_ptr[2*1]
chndtrix = np.PyUFunc_FromFuncAndData(ufunc_chndtrix_loops, ufunc_chndtrix_data, ufunc_chndtrix_types, 2, 3, 1, 0, "chndtrix", ufunc_chndtrix_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cosdg_loops[2]
cdef void *ufunc_cosdg_ptr[4]
cdef void *ufunc_cosdg_data[2]
cdef char ufunc_cosdg_types[4]
cdef char *ufunc_cosdg_doc = (
    "cosdg(x, out=None)\n"
    "\n"
    "Cosine of the angle `x` given in degrees.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Angle, given in degrees.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Cosine of the input.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "sindg, tandg, cotdg\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than using cosine directly.\n"
    "\n"
    ">>> x = 90 + 180 * np.arange(3)\n"
    ">>> sc.cosdg(x)\n"
    "array([-0.,  0., -0.])\n"
    ">>> np.cos(x * np.pi / 180)\n"
    "array([ 6.1232340e-17, -1.8369702e-16,  3.0616170e-16])")
ufunc_cosdg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cosdg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cosdg_types[0] = <char>NPY_FLOAT
ufunc_cosdg_types[1] = <char>NPY_FLOAT
ufunc_cosdg_types[2] = <char>NPY_DOUBLE
ufunc_cosdg_types[3] = <char>NPY_DOUBLE
ufunc_cosdg_ptr[2*0] = <void*>_func_cephes_cosdg
ufunc_cosdg_ptr[2*0+1] = <void*>(<char*>"cosdg")
ufunc_cosdg_ptr[2*1] = <void*>_func_cephes_cosdg
ufunc_cosdg_ptr[2*1+1] = <void*>(<char*>"cosdg")
ufunc_cosdg_data[0] = &ufunc_cosdg_ptr[2*0]
ufunc_cosdg_data[1] = &ufunc_cosdg_ptr[2*1]
cosdg = np.PyUFunc_FromFuncAndData(ufunc_cosdg_loops, ufunc_cosdg_data, ufunc_cosdg_types, 2, 1, 1, 0, "cosdg", ufunc_cosdg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cosm1_loops[2]
cdef void *ufunc_cosm1_ptr[4]
cdef void *ufunc_cosm1_data[2]
cdef char ufunc_cosm1_types[4]
cdef char *ufunc_cosm1_doc = (
    "cosm1(x, out=None)\n"
    "\n"
    "cos(x) - 1 for use when `x` is near zero.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Real valued argument.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Values of ``cos(x) - 1``.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "expm1, log1p\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than computing ``cos(x) - 1`` directly for\n"
    "``x`` around 0.\n"
    "\n"
    ">>> x = 1e-30\n"
    ">>> np.cos(x) - 1\n"
    "0.0\n"
    ">>> sc.cosm1(x)\n"
    "-5.0000000000000005e-61")
ufunc_cosm1_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cosm1_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cosm1_types[0] = <char>NPY_FLOAT
ufunc_cosm1_types[1] = <char>NPY_FLOAT
ufunc_cosm1_types[2] = <char>NPY_DOUBLE
ufunc_cosm1_types[3] = <char>NPY_DOUBLE
ufunc_cosm1_ptr[2*0] = <void*>_func_cephes_cosm1
ufunc_cosm1_ptr[2*0+1] = <void*>(<char*>"cosm1")
ufunc_cosm1_ptr[2*1] = <void*>_func_cephes_cosm1
ufunc_cosm1_ptr[2*1+1] = <void*>(<char*>"cosm1")
ufunc_cosm1_data[0] = &ufunc_cosm1_ptr[2*0]
ufunc_cosm1_data[1] = &ufunc_cosm1_ptr[2*1]
cosm1 = np.PyUFunc_FromFuncAndData(ufunc_cosm1_loops, ufunc_cosm1_data, ufunc_cosm1_types, 2, 1, 1, 0, "cosm1", ufunc_cosm1_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_cotdg_loops[2]
cdef void *ufunc_cotdg_ptr[4]
cdef void *ufunc_cotdg_data[2]
cdef char ufunc_cotdg_types[4]
cdef char *ufunc_cotdg_doc = (
    "cotdg(x, out=None)\n"
    "\n"
    "Cotangent of the angle `x` given in degrees.\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Angle, given in degrees.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function results.\n"
    "\n"
    "Returns\n"
    "-------\n"
    "scalar or ndarray\n"
    "    Cotangent at the input.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "sindg, cosdg, tandg\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> import scipy.special as sc\n"
    "\n"
    "It is more accurate than using cotangent directly.\n"
    "\n"
    ">>> x = 90 + 180 * np.arange(3)\n"
    ">>> sc.cotdg(x)\n"
    "array([0., 0., 0.])\n"
    ">>> 1 / np.tan(x * np.pi / 180)\n"
    "array([6.1232340e-17, 1.8369702e-16, 3.0616170e-16])")
ufunc_cotdg_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_cotdg_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_cotdg_types[0] = <char>NPY_FLOAT
ufunc_cotdg_types[1] = <char>NPY_FLOAT
ufunc_cotdg_types[2] = <char>NPY_DOUBLE
ufunc_cotdg_types[3] = <char>NPY_DOUBLE
ufunc_cotdg_ptr[2*0] = <void*>_func_cephes_cotdg
ufunc_cotdg_ptr[2*0+1] = <void*>(<char*>"cotdg")
ufunc_cotdg_ptr[2*1] = <void*>_func_cephes_cotdg
ufunc_cotdg_ptr[2*1+1] = <void*>(<char*>"cotdg")
ufunc_cotdg_data[0] = &ufunc_cotdg_ptr[2*0]
ufunc_cotdg_data[1] = &ufunc_cotdg_ptr[2*1]
cotdg = np.PyUFunc_FromFuncAndData(ufunc_cotdg_loops, ufunc_cotdg_data, ufunc_cotdg_types, 2, 1, 1, 0, "cotdg", ufunc_cotdg_doc, 0)

cdef np.PyUFuncGenericFunction ufunc_dawsn_loops[4]
cdef void *ufunc_dawsn_ptr[8]
cdef void *ufunc_dawsn_data[4]
cdef char ufunc_dawsn_types[8]
cdef char *ufunc_dawsn_doc = (
    "dawsn(x, out=None)\n"
    "\n"
    "Dawson's integral.\n"
    "\n"
    "Computes::\n"
    "\n"
    "    exp(-x**2) * integral(exp(t**2), t=0..x).\n"
    "\n"
    "Parameters\n"
    "----------\n"
    "x : array_like\n"
    "    Function parameter.\n"
    "out : ndarray, optional\n"
    "    Optional output array for the function values\n"
    "\n"
    "Returns\n"
    "-------\n"
    "y : scalar or ndarray\n"
    "    Value of the integral.\n"
    "\n"
    "See Also\n"
    "--------\n"
    "wofz, erf, erfc, erfcx, erfi\n"
    "\n"
    "References\n"
    "----------\n"
    ".. [1] Steven G. Johnson, Faddeeva W function implementation.\n"
    "   http://ab-initio.mit.edu/Faddeeva\n"
    "\n"
    "Examples\n"
    "--------\n"
    ">>> import numpy as np\n"
    ">>> from scipy import special\n"
    ">>> import matplotlib.pyplot as plt\n"
    ">>> x = np.linspace(-15, 15, num=1000)\n"
    ">>> plt.plot(x, special.dawsn(x))\n"
    ">>> plt.xlabel('$x$')\n"
    ">>> plt.ylabel('$dawsn(x)$')\n"
    ">>> plt.show()")
ufunc_dawsn_loops[0] = <np.PyUFuncGenericFunction>loop_d_d__As_f_f
ufunc_dawsn_loops[1] = <np.PyUFuncGenericFunction>loop_d_d__As_d_d
ufunc_dawsn_loops[2] = <np.PyUFuncGenericFunction>loop_D_D__As_F_F
ufunc_dawsn_loops[3] = <np.PyUFuncGenericFunction>loop_D_D__As_D_D
ufunc_dawsn_types[0] = <char>NPY_FLOAT
ufunc_dawsn_types[1] = <char>NPY_FLOAT
ufunc_dawsn_types[2] = <char>NPY_DOUBLE
ufunc_dawsn_types[3] = <char>NPY_DOUBLE
ufunc_dawsn_types[4] = <char>NPY_CFLOAT
ufunc_dawsn_types[5] = <char>NPY_CFLOAT
ufunc_dawsn_types[6] = <char>NPY_CDOUBLE
ufunc_dawsn_types[7] = <char>NPY_CDOUBLE
ufunc_dawsn_ptr[2*0] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn
ufunc_dawsn_ptr[2*0+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*1] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn
ufunc_dawsn_ptr[2*1+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*2] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex
ufunc_dawsn_ptr[2*2+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_ptr[2*3] = <void*>scipy.special._ufuncs_cxx._export_faddeeva_dawsn_complex
ufunc_dawsn_ptr[2*3+1] = <void*>(<char*>"dawsn")
ufunc_dawsn_data[0] = &ufunc_dawsn_ptr[2*0]
ufunc_dawsn_data[1] = &ufunc_dawsn_